# TASK-0001.2.1.7: Protocol-Based Refactor & Merge Commit Test

**Parent Story**: [STORY-0001.2.1](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 6
**Actual Hours**: -

## Objective

Refactor `CommitWalker` to use protocol-based design (following STORY-0001.2.2's `ChunkerProtocol` pattern) and fix the skipped merge commit test by implementing merge commit fixture support.

## Context

**Why This Task Exists:**

During story review, we identified that STORY-0001.2.1 doesn't follow Core Design Principle #1 (Protocol-Based Design for Future Rust Optimization) that was successfully applied in sibling story STORY-0001.2.2. This task brings STORY-0001.2.1 into alignment with the roadmap-mandated pattern.

**Protocol Pattern Rationale** (from ROADMAP.md):

- Enables future Rust optimization via PyO3 without breaking changes
- Uses FFI-compatible primitive types (str, int, bool, bytes)
- Provides clear swappability boundaries for implementations
- Consistent architecture across all core components

**Reference Implementation**: See STORY-0001.2.2 `ChunkerProtocol` (lines 141-163) for the exact pattern to follow.

## Acceptance Criteria

- [ ] `CommitWalkerProtocol` defined in `src/gitctx/core/protocols.py`
- [ ] Protocol uses only FFI-compatible primitive types (str, int, bool, bytes - no Path objects)
- [ ] `create_walker()` factory function returns `CommitWalkerProtocol`
- [ ] `CommitWalker` class implements protocol (verified by mypy strict mode)
- [ ] Merge commit fixture created with `create_merge` parameter
- [ ] Skipped test `test_merge_commit_detection` (line 183) now passes
- [ ] Protocol adherence tests added (3 new tests)
- [ ] All existing tests still pass (no regressions)
- [ ] Quality gates pass: `ruff check`, `ruff format`, `mypy --strict`, `pytest`
- [ ] Documentation updated in story README Technical Design section

## Implementation Plan

### Phase 1: Extract Protocol (TDD - 2 hours)

**Unit Tests First (RED)**

```python
# tests/unit/core/test_commit_walker.py - add new test class

class TestProtocolAdherence:
    """Test CommitWalker implements CommitWalkerProtocol correctly."""

    def test_commit_walker_implements_protocol(self, git_repo_factory, isolated_env):
        """CommitWalker satisfies CommitWalkerProtocol (duck typing verification)."""
        from gitctx.core.protocols import CommitWalkerProtocol
        from gitctx.core.commit_walker import CommitWalker

        # Verify walker has required methods
        assert hasattr(CommitWalker, 'walk')
        assert hasattr(CommitWalker, 'get_stats')

        # Verify method signatures match protocol
        # (mypy will verify at type-check time)

        # Verify return types use primitives only
        repo_path = git_repo_factory(num_commits=1)
        walker = CommitWalker(str(repo_path), config)

        # Check BlobRecord fields are primitives
        for blob_record in walker.walk():
            assert isinstance(blob_record.sha, str)
            assert isinstance(blob_record.content, bytes)
            assert isinstance(blob_record.size, int)
            for loc in blob_record.locations:
                assert isinstance(loc.commit_sha, str)
                assert isinstance(loc.file_path, str)  # Not Path!
                assert isinstance(loc.is_head, bool)
            break

    def test_factory_returns_protocol(self, git_repo_factory, isolated_env):
        """create_walker() returns CommitWalkerProtocol instance."""
        from gitctx.core import create_walker
        from gitctx.core.protocols import CommitWalkerProtocol

        repo_path = git_repo_factory(num_commits=1)
        walker = create_walker(str(repo_path), config)

        # Verify walker has protocol methods
        assert hasattr(walker, 'walk')
        assert hasattr(walker, 'get_stats')

        # Type checker verifies create_walker() -> CommitWalkerProtocol

    def test_ffi_primitive_type_constraints(self, git_repo_factory, isolated_env):
        """Walker API uses only FFI-compatible primitive types."""
        from gitctx.core import create_walker
        from pathlib import Path

        repo_path = git_repo_factory(num_commits=1)

        # Factory accepts str, not Path
        walker = create_walker(str(repo_path), config)  # str âœ“

        # Walk yields BlobRecord with primitive fields
        for blob_record in walker.walk():
            # All fields must be primitives for FFI compatibility
            assert not isinstance(blob_record.sha, Path)
            assert isinstance(blob_record.sha, str)
            assert isinstance(blob_record.content, bytes)

            for loc in blob_record.locations:
                # file_path must be str, not Path (FFI compatible)
                assert not isinstance(loc.file_path, Path)
                assert isinstance(loc.file_path, str)
            break
```

**Run tests** - All fail âœ“ (protocol doesn't exist yet)

**Implementation (GREEN)**

```python
# src/gitctx/core/protocols.py (extend existing file)

from typing import Iterator, Protocol, Callable
from gitctx.core.models import BlobRecord, WalkStats, WalkProgress

class CommitWalkerProtocol(Protocol):
    """Protocol for commit graph walking - can be fulfilled by Python or Rust.

    Enables future optimization: Python implementation now, Rust implementation
    later via PyO3 bindings, without breaking changes to consuming code.

    Design principles for FFI compatibility:
    - Use primitive types (str, int, bool, bytes) - no Path objects
    - Return dataclasses with primitive fields only
    - Stateful protocol: initialization separate from walk operation

    Example usage:
        walker = create_walker(repo_path, config)
        for blob_record in walker.walk():
            process(blob_record)
        stats = walker.get_stats()
    """

    def walk(
        self,
        progress_callback: Callable[[WalkProgress], None] | None = None
    ) -> Iterator[BlobRecord]:
        """Walk commits and yield unique blobs with location metadata.

        Args:
            progress_callback: Optional callback invoked every 10 commits
                             with WalkProgress metrics (commits_seen, unique_blobs, etc.)

        Yields:
            BlobRecord containing:
            - sha: str (blob SHA-1 hash)
            - content: bytes (blob content)
            - size: int (blob size in bytes)
            - locations: list[BlobLocation] (all commits/paths where blob appears)

        Raises:
            PartialCloneError: If repository is a partial clone (missing objects)
            ShallowCloneError: If repository is a shallow clone (incomplete history)
            GitRepositoryError: If repository is invalid or inaccessible
        """
        ...

    def get_stats(self) -> WalkStats:
        """Get statistics from completed or in-progress walk.

        Returns:
            WalkStats with commits_seen, blobs_indexed, blobs_skipped, errors
        """
        ...


def create_walker(
    repo_path: str,
    config: 'GitCtxSettings',
    already_indexed: set[str] | None = None
) -> CommitWalkerProtocol:
    """Factory function to create a commit walker.

    This allows easy swapping of implementations in the future
    (e.g., Rust implementation via PyO3) without changing consuming code.

    Args:
        repo_path: Path to git repository (str for FFI compatibility, not Path)
        config: GitCtxSettings instance with walker configuration
        already_indexed: Set of blob SHAs to skip (for resume from partial index)

    Returns:
        Walker instance implementing CommitWalkerProtocol

    Raises:
        PartialCloneError: If repository is a partial clone
        ShallowCloneError: If repository is a shallow clone
        GitRepositoryError: If repository path is invalid

    Example:
        walker = create_walker("/path/to/repo", config)
        for blob in walker.walk():
            print(f"Found blob {blob.sha} in {len(blob.locations)} commits")
    """
    from gitctx.core.commit_walker import CommitWalker
    return CommitWalker(repo_path, config, already_indexed)
```

```python
# src/gitctx/core/__init__.py - add export

from gitctx.core.protocols import CommitWalkerProtocol, create_walker

__all__ = [
    'CommitWalkerProtocol',
    'create_walker',
    # ... existing exports
]
```

**Run tests** - All pass âœ“

**Refactor**

- [ ] Update type hints in consuming code to use `CommitWalkerProtocol`
- [ ] Verify mypy strict mode passes (no type errors)
- [ ] Run tests - still pass âœ“

### Phase 2: Merge Commit Fixture (TDD - 2 hours)

**Unit Tests First (RED - Fix Skipped Test)**

```python
# tests/unit/core/test_commit_walker.py - line 179

def test_merge_commit_detection(self, git_repo_factory, isolated_env):
    """Merge commits have is_merge=True."""
    # Remove pytest.skip() line

    # Arrange - create repo with merge commit
    repo_path = git_repo_factory(num_commits=3, create_merge=True)
    walker = create_walker(str(repo_path), config)

    # Act
    blobs = list(walker.walk())

    # Assert - find merge commit's blobs
    merge_blobs = [
        blob for blob in blobs
        if any(loc.is_merge for loc in blob.locations)
    ]
    non_merge_blobs = [
        blob for blob in blobs
        if all(not loc.is_merge for loc in blob.locations)
    ]

    assert len(merge_blobs) > 0, "Should have blobs from merge commit"
    assert len(non_merge_blobs) > 0, "Should have blobs from non-merge commits"
```

**Run test** - Fails (fixture doesn't support `create_merge` parameter) âœ“

**Implementation (GREEN)**

```python
# tests/fixtures/git_repo_factory.py - modify existing fixture

@pytest.fixture
def git_repo_factory(tmp_path_factory, git_isolation_base):
    """Factory to create git repos with configurable commits."""

    def _factory(
        num_commits: int = 10,
        files_per_commit: int = 2,
        create_merge: bool = False,  # NEW PARAMETER
    ) -> Path:
        """Create a git repo with specified structure.

        Args:
            num_commits: Number of commits to create
            files_per_commit: Number of files to modify per commit
            create_merge: If True, create a merge commit with 2 parents
        """
        repo_path = tmp_path_factory.mktemp("repo")
        repo = pygit2.init_repository(repo_path)

        # Create initial commits on main branch
        initial_commits = num_commits if not create_merge else num_commits - 2
        for i in range(initial_commits):
            # ... existing commit creation logic

        if create_merge:
            # Create feature branch
            feature_branch = repo.branches.create(
                "feature",
                repo.head.peel()
            )
            repo.checkout(feature_branch)

            # Create 1 commit on feature branch
            feature_file = repo_path / "feature.py"
            feature_file.write_text("def feature(): pass")
            repo.index.add("feature.py")
            repo.index.write()
            tree = repo.index.write_tree()

            feature_commit = repo.create_commit(
                "refs/heads/feature",
                author, committer,
                "Add feature",
                tree,
                [repo.head.peel().id]
            )

            # Switch back to main
            repo.checkout(repo.branches["main"])

            # Create merge commit (2 parents)
            main_commit = repo.head.peel()

            # Read feature tree
            feature_tree = repo.get(feature_commit).tree

            # Merge (use feature tree as merge result)
            merge_commit = repo.create_commit(
                "refs/heads/main",
                author, committer,
                "Merge feature branch",
                feature_tree.id,
                [main_commit.id, feature_commit]  # 2 PARENTS!
            )

            repo.head.set_target(merge_commit)

        return repo_path

    return _factory
```

**Run test** - Passes âœ“

**Refactor**

- [ ] Extract merge creation to helper function `_create_merge_commit()`
- [ ] Run tests - still pass âœ“

### Phase 3: Integration & Documentation (2 hours)

**Update Story README:**

- [ ] Add protocol specification to Technical Design section (copy from protocols.py docstring)
- [ ] Add protocol adherence tests to Edge Case Scenarios section
- [ ] Update Success Criteria to mention protocol design
- [ ] Update task table with TASK-0001.2.1.7 status

**Run Quality Gates:**

```bash
# All must pass
uv run ruff check src tests
uv run ruff format src tests
uv run mypy src --strict
uv run pytest -v --cov=src/gitctx
```

**Final Verification:**

- [ ] All 10 BDD scenarios pass (no regressions)
- [ ] All unit tests pass (including new protocol tests)
- [ ] No skipped tests (merge commit test now enabled)
- [ ] Coverage >90%
- [ ] Type checker passes in strict mode

## Checklist

### Phase 1: Protocol Extraction (TDD)
- [ ] Write `test_commit_walker_implements_protocol` - verify protocol satisfaction
- [ ] Write `test_factory_returns_protocol` - verify factory type hints
- [ ] Write `test_ffi_primitive_type_constraints` - verify no Path objects
- [ ] Run tests - all 3 fail âœ“
- [ ] Create `CommitWalkerProtocol` in `src/gitctx/core/protocols.py`
- [ ] Add `create_walker()` factory function
- [ ] Export from `src/gitctx/core/__init__.py`
- [ ] Verify `CommitWalker` satisfies protocol (mypy)
- [ ] Run tests - all 3 pass âœ“
- [ ] Update type hints in consuming code
- [ ] Run mypy strict - passes âœ“

### Phase 2: Merge Commit Fixture (TDD)
- [ ] Remove `pytest.skip()` from `test_merge_commit_detection` (line 183)
- [ ] Update test to use `git_repo_factory(create_merge=True)`
- [ ] Run test - fails (fixture doesn't support parameter) âœ“
- [ ] Add `create_merge` parameter to `git_repo_factory` fixture
- [ ] Implement merge commit creation logic (feature branch + merge)
- [ ] Run test - passes âœ“
- [ ] Extract `_create_merge_commit()` helper function
- [ ] Run tests - still pass âœ“

### Phase 3: Integration & Documentation
- [ ] Update story README Technical Design with protocol specification
- [ ] Add protocol tests to Edge Case Scenarios section
- [ ] Update Success Criteria to include protocol design
- [ ] Run full test suite - all pass
- [ ] Run quality gates (ruff, mypy, pytest) - all pass
- [ ] Update TASK status to âœ… Complete
- [ ] Update story progress to 100%

## Files Modified

**Modified:**
- `src/gitctx/core/protocols.py` - Add `CommitWalkerProtocol` and `create_walker()`
- `src/gitctx/core/__init__.py` - Export protocol and factory
- `tests/unit/core/test_commit_walker.py` - Enable merge test, add 3 protocol tests
- `tests/fixtures/git_repo_factory.py` - Add `create_merge` parameter
- `docs/tickets/INIT-0001/EPIC-0001.2/STORY-0001.2.1/README.md` - Update Technical Design

**No new files created** (refactoring existing code)

## Testing Strategy

**Unit Tests (TDD):**
- Protocol adherence (3 new tests)
- Merge commit detection (fix skipped test)
- All existing tests (regression check)

**BDD Tests:**
- No new scenarios (protocol is implementation detail)
- All existing scenarios must still pass

**Quality Gates:**
- ruff: No warnings, strict config
- mypy: Strict mode, no errors
- pytest: All tests pass, coverage >90%

## Success Criteria

Task is complete when:

- âœ… Protocol pattern implemented following STORY-0001.2.2 exactly
- âœ… All 3 protocol adherence tests pass
- âœ… Merge commit test no longer skipped and passes
- âœ… All existing tests still pass (no regressions)
- âœ… mypy strict mode passes (protocol types correct)
- âœ… Quality gates pass (ruff, mypy, pytest)
- âœ… Documentation updated in story README

## Notes

- **Reference**: Follow STORY-0001.2.2's `ChunkerProtocol` pattern exactly for consistency
- **FFI Compatibility**: Critical that all protocol methods use primitive types (str, int, bool, bytes)
- **No Breaking Changes**: Existing code continues to work (factory function is additive)
- **Merge Fixture**: Simple implementation using `git merge --no-ff` pattern in fixture

---

**Created**: 2025-10-07
**Last Updated**: 2025-10-07
