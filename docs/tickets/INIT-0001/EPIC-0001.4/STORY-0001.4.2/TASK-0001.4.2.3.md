# TASK-0001.4.2.3: Integrate GitHeadBooster into LanceDBStore Search Pipeline

**Parent Story**: [STORY-0001.4.2](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 3-4
**Actual Hours**: -

## Objective

Integrate GitHeadBooster into LanceDBStore.search() pipeline using TDD. Apply HEAD boost after hybrid search but before post-filtering. Update search() to inject is_head metadata from LanceDB results. Implement remaining BDD steps for ranking verification and tie-breaking.

## BDD Progress

**Before this task**: 1/3 scenarios passing
**After this task**: 3/3 scenarios passing (all HEAD boosting scenarios âœ…)

**Scenarios for this task:**
- Scenario 2: Boost applies to hybrid scores, not absolute ranking (full implementation)
- Scenario 3: Equal semantic matches prefer HEAD code (tie-breaking verification)

## Implementation Checklist

### Phase 1: Unit Tests First (TDD - RED)

- [ ] Modify `tests/unit/storage/test_lancedb_store.py`
  - [ ] Test search() with HEAD booster integration
  - [ ] Test search() extracts is_head from LanceDB metadata
  - [ ] Test search() applies boost after hybrid scoring
  - [ ] Test search() with max_distance=0.5 excludes results with distance > 0.5 (same filtering behavior as pre-boost)
  - [ ] Test search() with mixed HEAD and historical results
  - [ ] Test search() ranking order after boost
  - [ ] Test search() with all HEAD results (all boosted)
  - [ ] Test search() with all historical results (no boost)
  - [ ] Test search() with empty results (no crash)
- [ ] Create `tests/unit/storage/test_lancedb_integration.py`
  - [ ] Test full pipeline: hybrid search â†’ boost â†’ filter â†’ rank
  - [ ] Test boost doesn't override semantic relevance (0.95 > 0.6*1.5)
  - [ ] Test boost breaks ties (0.8*1.5 > 0.8)
  - [ ] Test limit parameter respected after boost
  - [ ] Test filter_head_only works with boost
- [ ] Run tests - all fail ðŸ”´

### Phase 2: Implementation (GREEN)

- [ ] Modify `src/gitctx/storage/lancedb_store.py`
  - [ ] Import GitHeadBooster
  - [ ] Add booster initialization in __init__ (multiplier=1.5)
  - [ ] Update search() method:
    ```python
    def search(
        self,
        query_vector: np.ndarray,
        limit: int = 10,
        filter_head_only: bool = False,
        max_distance: float = 1.0,
    ) -> list[SearchResult]:
        """Hybrid search with HEAD boosting."""

        # 1. Hybrid search (from TASK-0001.4.1.3)
        results = self.table.search(...).rerank(...)

        # 2. Extract is_head from LanceDB metadata
        search_results = [
            self._to_search_result(r, is_head=r.get('is_head', False))
            for r in results
        ]

        # 3. Apply HEAD boost
        boosted = self.booster.boost(search_results)

        # 4. Post-filter by distance (existing logic)
        filtered = [r for r in boosted if r.distance <= max_distance]

        # 5. Re-rank by boosted hybrid_score
        ranked = sorted(filtered, key=lambda r: r.hybrid_score, reverse=True)

        # 6. Apply limit
        return ranked[:limit]
    ```
  - [ ] Update _to_search_result() to accept is_head parameter
  - [ ] Populate is_head field in SearchResult objects
- [ ] Run unit tests - all pass ðŸŸ¢

### Phase 3: Refactor

- [ ] Extract pipeline stages into helper methods:
  - [ ] _apply_boost(results: list[SearchResult]) -> list[SearchResult]
  - [ ] _post_filter(results: list[SearchResult], max_distance: float) -> list[SearchResult]
  - [ ] _rerank_by_score(results: list[SearchResult]) -> list[SearchResult]
- [ ] Add docstring explaining pipeline order (hybrid â†’ boost â†’ filter â†’ rank â†’ limit)
- [ ] Verify all edge cases covered (empty, all HEAD, all historical)
- [ ] Run tests - all still pass ðŸŸ¢

### Phase 4: BDD Implementation (Remaining Scenarios)

- [ ] Modify `tests/e2e/steps/head_boosting_steps.py`
- [ ] Implement step: "And boost does not override semantic relevance"
  - [ ] Parse search results
  - [ ] Verify historical file with higher semantic score (0.95) ranks above HEAD file with lower boosted score (0.6*1.5=0.9)
  - [ ] Verify math: 0.95 > 0.9 (relevance beats boost)
- [ ] Implement step: "Then {file} should rank above {other_file}"
  - [ ] Parse result ranking
  - [ ] Verify file order matches expected ranking
  - [ ] Use for both Scenario 1 and Scenario 2
- [ ] Implement step: "And HEAD boost breaks ties"
  - [ ] Parse results with identical semantic scores
  - [ ] Verify HEAD file ranks first (0.8*1.5=1.2 > 0.8)
  - [ ] Verify tie-breaking is deterministic
- [ ] Run all 3 BDD scenarios - all pass âœ…

### Verification

- [ ] All unit tests pass (15+ new integration tests)
- [ ] All 3 BDD scenarios pass (keyword, relevance, tie-breaking)
- [ ] Code coverage >90% for modified LanceDBStore.search()
- [ ] Mypy type checking passes
- [ ] Existing hybrid search tests still pass (no regressions)
- [ ] Commit: `feat(TASK-0001.4.2.3): Integrate HEAD booster in search pipeline (3/3 BDD passing)`

## Files to Modify/Create

- **MODIFY**: `src/gitctx/storage/lancedb_store.py` (~80 lines changed: booster integration, pipeline refactor)
- **MODIFY**: `tests/unit/storage/test_lancedb_store.py` (~100 lines added: booster integration tests)
- **CREATE**: `tests/unit/storage/test_lancedb_integration.py` (~200 lines, full pipeline tests)
- **MODIFY**: `tests/e2e/steps/head_boosting_steps.py` (~60 lines, implement 3 remaining steps)

## Pattern Reuse

- **Pipeline Pattern** - Chain transformations on search results
  - Similar to embedder pipeline in `src/gitctx/models/embedder.py`
  - Each stage returns new list, maintains immutability
- **Score-based Ranking** - Sort by hybrid_score descending
  - Similar to existing distance-based sorting in LanceDBStore
  - Use `sorted()` with key function for clarity
- **Post-filtering Workaround** - Distance filter after search (LanceDB limitation)
  - Keep existing pattern from TASK-0001.4.1.3
  - Works with boosted scores (filter on distance, rank on hybrid_score)

## Technical Notes

### Search Pipeline Order (Critical!)

```python
# Correct order (MUST follow this sequence):
1. Hybrid search (BM25 + vector with RRF)
2. Extract is_head metadata from results
3. Apply HEAD boost (multiply hybrid_score by 1.5)
4. Post-filter by distance threshold
5. Re-rank by boosted hybrid_score
6. Apply limit
```

**Why this order:**
- Boost AFTER hybrid search (so RRF score is stable baseline)
- Boost BEFORE ranking (so HEAD results rank higher)
- Filter BEFORE limit (so distance threshold respected)
- Rank BEFORE limit (so top-N are truly best)

### HEAD Metadata Extraction

LanceDB stores is_head as chunk metadata:

```python
# LanceDB result format
{
    'content': '...',
    '_distance': 0.15,
    '_score': 0.92,
    'is_head': True,  # From chunk metadata (indexed in EPIC-0001.3)
    'commit_sha': 'abc123',
    # ... other fields
}
```

Extract in _to_search_result():

```python
def _to_search_result(self, result: dict, is_head: bool = False) -> SearchResult:
    """Convert LanceDB result to SearchResult with is_head flag."""
    return SearchResult(
        content=result['content'],
        # ... other fields ...
        is_head=is_head,  # Injected from metadata
        commit_sha=result.get('commit_sha'),
        hybrid_score=result['_score'],
    )
```

### Boost vs. Relevance Example

From BDD Scenario 2 (boost doesn't override semantic relevance):

```python
# Historical file with high semantic score
historical_score = 0.95  # Very relevant

# HEAD file with lower semantic score, boosted
head_score = 0.6 * 1.5 = 0.9  # Less relevant, boosted

# Expected ranking: historical first (0.95 > 0.9)
# Boost helps HEAD, but doesn't override better matches
```

### Tie-Breaking Example

From BDD Scenario 3 (boost breaks ties):

```python
# Two files with identical semantic scores
head_score = 0.8 * 1.5 = 1.2  # Boosted
historical_score = 0.8  # Not boosted

# Expected ranking: HEAD first (1.2 > 0.8)
# Boost is the tie-breaker
```

## Dependencies

- **TASK-0001.4.2.2** (GitHeadBooster Class) - Must complete first (booster class must exist)
- **TASK-0001.4.1.3** (Hybrid Search Implementation) - Must complete first (hybrid_score field must exist)
