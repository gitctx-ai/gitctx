# TASK-0001.4.1.3: Hybrid Search Implementation in LanceDBStore

**Parent Story**: [STORY-0001.4.1](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 4-5
**Actual Hours**: -

## Objective

Implement hybrid search in LanceDBStore using LanceDB's BM25 + vector search with RRF (Reciprocal Rank Fusion) at K=60. Extract and populate score breakdown fields in SearchResult from LanceDB response (_distance, _score, _relevance_score). Implement all BDD steps for score verification and ranking validation.

## BDD Progress

**Before this task**: 1/3 scenarios passing
**After this task**: 3/3 scenarios passing (all hybrid search scenarios âœ…)

**Scenarios for this task:**
- Scenario 1: Hybrid search finds exact keyword matches (complete with score verification)
- Scenario 2: Hybrid search finds semantic matches (full implementation)
- Scenario 3: Hybrid search combines keyword and semantic ranking (full implementation)

## Implementation Checklist

### Phase 1: Unit Tests First (TDD - RED)

- [ ] Create `tests/unit/storage/test_lancedb_hybrid.py`
  - [ ] Test hybrid query construction (query_type='hybrid')
  - [ ] Test RRFReranker instantiation (K=60, return_score='all')
  - [ ] Test score extraction from LanceDB results (_distance, _score, _relevance_score)
  - [ ] Test BM25 score populated from _score field
  - [ ] Test vector score populated from (1.0 - _distance)
  - [ ] Test hybrid score populated from _relevance_score field
  - [ ] Test post-filtering compatibility (max_distance still works)
  - [ ] Test limit parameter respected after reranking
  - [ ] Test filter_head_only works with hybrid search
  - [ ] Test empty results handling
  - [ ] Test score breakdown with real LanceDB response structure
  - [ ] Test query_text parameter required for hybrid search
- [ ] Run tests - all fail ðŸ”´

### Phase 2: Implementation (GREEN)

- [ ] Modify `src/gitctx/storage/lancedb_store.py`
  - [ ] Import SearchStrategy protocol (for type checking)
  - [ ] Import rerankers from lancedb
  - [ ] Update search() method signature: add query_text parameter
  - [ ] Update search() method docstring (mention hybrid search)
  - [ ] Create RRFReranker instance: `rerankers.RRFReranker(K=60, return_score='all')`
  - [ ] Change query construction:
    - [ ] Use `query_type='hybrid'` instead of 'vector'
    - [ ] Add `.vector(query_vector)` call
    - [ ] Add `.text(query_text)` call (required for BM25)
  - [ ] Add `.rerank(rrf)` call after .limit()
  - [ ] Extract score breakdown from LanceDB response fields:
    - [ ] vector_score = 1.0 - result['_distance']
    - [ ] bm25_score = result.get('_score')  # May be None
    - [ ] hybrid_score = result.get('_relevance_score')  # May be None
  - [ ] Update _to_search_result() helper to populate score fields
  - [ ] Maintain post-filtering for max_distance (LanceDB limitation workaround)
  - [ ] Preserve filter_head_only functionality
- [ ] Run unit tests - all pass ðŸŸ¢

### Phase 3: Refactor

- [ ] Extract score parsing into helper method: `_extract_scores(result: dict) -> tuple[float, float, float]`
- [ ] Add docstring explaining RRF k=60 choice (LanceDB default, no tuning needed)
- [ ] Verify post-filtering still works (test with max_distance=0.5)
- [ ] Run tests - all still pass ðŸŸ¢

### Phase 4: BDD Implementation (Complete All Steps)

- [ ] Modify `tests/e2e/steps/hybrid_search_steps.py`
- [ ] Implement step: "And the result should have BM25 score > 0.7 (keyword match)"
  - [ ] Parse SearchResult object from context
  - [ ] Verify result.bm25_score is not None
  - [ ] Verify result.bm25_score > 0.7 (strong keyword match)
  - [ ] Optionally verify bm25_score > vector_score for keyword-heavy query
- [ ] Implement step: "And results should have vector scores > 0.7 (semantic match)"
  - [ ] Parse multiple SearchResult objects
  - [ ] Verify each result.vector_score > 0.7 (strong semantic match)
  - [ ] Optionally verify vector_score > bm25_score for semantic-heavy query
- [ ] Implement step: "Then {file} should rank {position} (keyword + semantic match)"
  - [ ] Parse result ranking
  - [ ] Verify file at expected position
  - [ ] Optionally verify hybrid_score explanation (keyword + semantic)
- [ ] Implement step: "And {file} should rank {position} (semantic match)"
  - [ ] Parse result ranking
  - [ ] Verify semantic-only results rank correctly
- [ ] Run all 3 BDD scenarios - all pass âœ…

### Verification

- [ ] All unit tests pass (11+ tests for hybrid search)
- [ ] All 3 BDD scenarios pass (keyword, semantic, combined ranking)
- [ ] Code coverage >90% for modified LanceDBStore.search()
- [ ] Mypy type checking passes
- [ ] No regressions in existing search tests
- [ ] Commit: `feat(TASK-0001.4.1.3): Hybrid search with RRF (3/3 BDD passing)`

## Files to Modify

- **MODIFY**: `src/gitctx/storage/lancedb_store.py` (~50 lines changed: hybrid query, score extraction)
- **CREATE**: `tests/unit/storage/test_lancedb_hybrid.py` (~250 lines, comprehensive hybrid search tests)
- **MODIFY**: `tests/e2e/steps/hybrid_search_steps.py` (~80 lines added, implement 4 score/ranking steps)

## Pattern Reuse

- **LanceDBStore.search() post-filtering** (`src/gitctx/storage/lancedb_store.py:309`) - Distance threshold workaround
  - Keep existing post-filter: `filtered = [r for r in results if r['_distance'] <= max_distance]`
  - Works with hybrid search (LanceDB limitation documented in issue #745)
- **_to_search_result() helper** (`src/gitctx/storage/lancedb_store.py`) - Result conversion pattern
  - Extend to populate bm25_score, vector_score, hybrid_score fields
  - Maintains clean separation of LanceDB format from SearchResult type

## Technical Notes

### LanceDB Hybrid Search API (Validated 2025-10-17)

```python
from lancedb import rerankers

# Create RRF reranker (K=60 default, return all scores)
rrf = rerankers.RRFReranker(K=60, return_score='all')

# Hybrid query
results = (
    self.table.search(query_type='hybrid')
    .vector(query_vector)              # Vector component
    .text(query_text)                  # Text component (required for BM25)
    .limit(limit * 2)                  # Get more for post-filtering
    .rerank(rrf)                       # Apply RRF fusion
    .to_list()
)
```

**Key points:**
- `query_type='hybrid'` enables BM25 + vector search
- Must provide both `.vector()` and `.text()` for hybrid mode
- RRF K=60 is research-backed default (no tuning needed)
- `return_score='all'` returns _distance, _score, _relevance_score fields
- Post-filtering for max_distance happens after search (limitation workaround)

### Score Extraction (Validated 2025-10-17)

LanceDB hybrid search result format:
```python
{
    '_distance': 0.15,            # Cosine distance (float, 0-âˆž, lower = more similar)
    '_score': 1.45,               # BM25 keyword score (float or None, higher = better)
    '_relevance_score': 0.0328,   # RRF combined score (float, 0-1, higher = more relevant)
    'chunk_content': '...',
    'file_path': '...',
    # ... other fields
}
```

Score mapping to SearchResult fields:
- `vector_score = 1.0 - result['_distance']` (convert distance to cosine similarity)
- `bm25_score = result.get('_score')` (BM25 score from FTS, may be None)
- `hybrid_score = result.get('_relevance_score')` (RRF fusion score, may be None)

### Performance Targets

Per story acceptance criteria:
- Search latency: Should be comparable to vector-only (LanceDB optimizes hybrid queries)
- Benchmark: ~470 QPS on 130K documents (M2 MacBook Pro, from prrao87/lancedb-study)

## Dependencies

- **TASK-0001.4.1.2** (SearchStrategy Protocol) - Must complete first (SearchResult score fields must exist)
