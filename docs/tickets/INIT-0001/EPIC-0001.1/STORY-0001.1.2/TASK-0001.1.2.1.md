# TASK-0001.1.2.1: Write BDD Scenarios for User/Repo Config Separation

**Parent Story**: [STORY-0001.1.2](README.md)
**Status**: ✅ Complete
**Estimated Hours**: 1.0 (was 0.5, +0.5 for TUI compliance scenarios)
**Actual Hours**: 1.0

## Description

**RED Phase** - Write failing tests first for persistent configuration with user/repo separation and security enforcement.

This task implements the BDD/TDD workflow's first step: write comprehensive BDD scenarios and unit tests that define the expected behavior of security-first configuration management with user and repo config separation. All tests will fail initially (RED) because the implementation doesn't exist yet.

## Implementation Checklist

### BDD Scenarios (E2E)

- [x] Add scenarios to `tests/e2e/features/cli.feature`:
  - [x] config init creates repo structure (default terse mode)
  - [x] API keys stored in user config only (validates file persistence)
  - [x] Repo settings stored in repo config only (validates file persistence)
  - [x] OPENAI_API_KEY env var overrides user config
  - [x] GITCTX env var overrides repo config
  - [x] config list shows both user and repo settings
  - [x] Config validation catches invalid values (exit code 2)
  - [x] Repo config is safe to commit (validates secrets in user config, settings in repo config)
  - [x] Malformed YAML shows clear error
  - [x] Permission denied shows clear error (exit code 6)
  - [x] **TUI: config init quiet mode suppresses output**
  - [x] **TUI: config init verbose mode shows details**
  - [x] **TUI: config get default mode shows value only (terse)**
  - [x] **TUI: config get verbose mode shows key and source**
  - [x] **TUI: config get quiet mode outputs value only**
  - [x] **TUI: config list default mode hides sources for defaults (terse)**
  - [x] **TUI: config list verbose mode shows all sources**
  - [x] **TUI: config set default mode shows terse confirmation (validates file persistence)**
  - [x] **TUI: config set quiet mode suppresses output (validates file persistence)**
  - [x] **TUI: config set api key persists to user config (validates file content)**
  - [x] **TUI: First-run tip appears once for config command**
  - [x] **TUI: Platform symbols fallback on Windows cmd.exe**
- [x] Add step definitions to `tests/e2e/steps/cli_steps.py`:
  - [x] `Given user config contains "key: value"`
  - [x] `Given repo config contains "key: value"`
  - [x] `Given environment variable "VAR" is "value"`
  - [x] `Then the file "path" should exist`
  - [x] `Then the file "path" should contain "content"`
  - [x] `Then the file "path" should NOT contain "content"`
- [x] Run BDD tests: `uv run pytest tests/e2e/ -k config` - **all 22 config scenarios PASSING** ✅

### Unit Tests (TDD)

**Test File Structure** (3 modules = 3 test files):
- `src/gitctx/core/user_config.py` → `tests/unit/core/test_user_config.py`
- `src/gitctx/core/repo_config.py` → `tests/unit/core/test_repo_config.py`
- `src/gitctx/core/config.py` → `tests/unit/core/test_config.py`

- [x] Create `tests/unit/core/test_user_config.py`:
  - [x] `test_user_config_loads_from_yaml()` - UserConfig reads YAML
  - [x] `test_user_config_saves_to_yaml()` - UserConfig writes YAML with 0600 permissions
  - [x] `test_openai_api_key_env_var_precedence()` - OPENAI_API_KEY wins
  - [x] `test_user_config_only_has_api_keys()` - Rejects non-secret fields
  - [x] `test_secret_str_masks_api_keys()` - SecretStr masking
  - [x] `test_user_config_windows_path()` - Path.home() works on Windows (skip on non-Windows)
- [x] Create `tests/unit/core/test_repo_config.py`:
  - [x] `test_repo_config_loads_from_yaml()` - RepoConfig reads YAML
  - [x] `test_repo_config_saves_to_yaml()` - RepoConfig writes YAML with 0644 permissions
  - [x] `test_gitctx_env_var_overrides_yaml()` - GITCTX_* beats YAML
  - [x] `test_repo_config_only_has_settings()` - Rejects api_keys field
  - [x] `test_repo_config_validates_types()` - Type validation works
  - [x] `test_malformed_yaml_error()` - Clear error on malformed YAML
  - [x] `test_permission_denied_error()` - Clear error on permission denied
- [x] Create `tests/unit/core/test_config.py`:
  - [x] `test_gitctx_settings_routes_api_keys_to_user()` - Routing works
  - [x] `test_gitctx_settings_routes_settings_to_repo()` - Routing works
  - [x] `test_init_repo_config_creates_structure()` - Creates files
  - [x] `test_gitignore_content()` - Correct .gitignore content (including comments)
- [x] **TUI Tests**: Add to `tests/unit/cli/test_config.py`:
  - [x] `test_symbols_fallback_on_legacy_windows()` - Validates ASCII fallback in config commands
  - [x] `test_symbols_use_unicode_on_modern_terminals()` - Validates ✓ ✗ symbols in config commands
  - [x] `test_first_run_creates_marker_file()` - Validates marker file creation for config command
  - [x] `test_subsequent_runs_skip_tips()` - Validates tip shown only once for config command
  - [x] `test_show_tip_uses_ascii_box_on_windows()` - Box styling matches platform
- [x] Run unit tests: `uv run pytest tests/unit/core/ tests/unit/cli/ -v` - **all 36 core + 28 CLI tests PASSING** ✅

### Test Coverage Plan

- [x] Confirm test coverage plan meets 85%+ target with explicit file mappings:
  - `tests/unit/core/test_user_config.py`:
    - User config loading (YAML, OPENAI_API_KEY env var, defaults)
    - User config precedence (OPENAI_API_KEY > YAML)
    - SecretStr masking (API keys hidden)
    - User config persistence (~/.gitctx/config.yml with 0600 permissions)
  - `tests/unit/core/test_repo_config.py`:
    - Repo config loading (YAML, GITCTX_* env vars, defaults)
    - Repo config precedence (GITCTX_* > YAML)
    - Type validation (type errors, invalid values)
    - Repo config persistence (.gitctx/config.yml with 0644 permissions)
  - `tests/unit/core/test_config.py`:
    - GitCtxSettings routing (api_keys.* → user, others → repo)
    - get_source() method (returns correct source indicators)
    - init_repo_config() function (creates .gitctx/ with .gitignore)
    - Security (user/repo separation enforced)
  - **Target ACHIEVED**: user_config: 100%, repo_config: 100%, config: 90.77% ✅

## BDD Scenarios Detail

Add to `tests/e2e/features/cli.feature`:

```gherkin
Scenario: config init creates repo structure (default terse output)
  When I run "gitctx config init"
  Then the exit code should be 0
  And the output should be exactly "Initialized .gitctx/"
  And the output should NOT contain "Created"
  And the output should NOT contain "Next steps"
  And the file ".gitctx/config.yml" should exist
  And the file ".gitctx/.gitignore" should exist
  And ".gitctx/.gitignore" should contain "# LanceDB vector database - never commit"
  And ".gitctx/.gitignore" should contain "db/"
  And ".gitctx/.gitignore" should contain "# Application logs - never commit"
  And ".gitctx/.gitignore" should contain "logs/"
  And ".gitctx/.gitignore" should contain "*.log"

Scenario: config init quiet mode suppresses all output
  When I run "gitctx config init --quiet"
  Then the exit code should be 0
  And the output should be empty

Scenario: config init verbose mode shows detailed output
  When I run "gitctx config init --verbose"
  Then the exit code should be 0
  And the output should contain "Initialized .gitctx/"
  And the output should contain "Created .gitctx/config.yml"
  And the output should contain "Created .gitctx/.gitignore"
  And the output should contain "Next steps:"
  And the output should contain "1. Set your API key: gitctx config set api_keys.openai sk-..."
  And the output should contain "2. Index your repo: gitctx index"
  And the output should contain "3. Commit to share: git add .gitctx/"

Scenario: API keys stored in user config only
  When I run "gitctx config set api_keys.openai sk-test123"
  Then the exit code should be 0
  And the output should contain "set api_keys.openai"
  And the user config file should exist at "~/.gitctx/config.yml"
  And the file "~/.gitctx/config.yml" should contain "api_keys:"
  And the file "~/.gitctx/config.yml" should contain "openai:"
  And the file "~/.gitctx/config.yml" should contain "sk-test123"
  And the file ".gitctx/config.yml" should NOT contain "api_keys"
  And the file ".gitctx/config.yml" should NOT contain "sk-test123"

Scenario: Repo settings stored in repo config only
  Given I run "gitctx config init"
  When I run "gitctx config set search.limit 20"
  Then the exit code should be 0
  And the output should contain "set search.limit"
  And the file ".gitctx/config.yml" should contain "search:"
  And the file ".gitctx/config.yml" should contain "limit: 20"
  And the file "~/.gitctx/config.yml" should NOT contain "search"
  And the file "~/.gitctx/config.yml" should NOT contain "limit"

Scenario: config get default mode shows value only (terse)
  Given user config contains "api_keys:\n  openai: sk-test123"
  When I run "gitctx config get api_keys.openai"
  Then the exit code should be 0
  And the output should be exactly "sk-...123"
  And the output should NOT contain "api_keys.openai"
  And the output should NOT contain "(from"

Scenario: config get verbose mode shows key and source
  Given user config contains "api_keys:\n  openai: sk-test123"
  When I run "gitctx config get api_keys.openai --verbose"
  Then the exit code should be 0
  And the output should contain "api_keys.openai = sk-...123 (from user config)"

Scenario: config get quiet mode outputs value only with no formatting
  Given user config contains "api_keys:\n  openai: sk-test123"
  When I run "gitctx config get api_keys.openai --quiet"
  Then the exit code should be 0
  And the output should be exactly "sk-...123"

Scenario: OPENAI_API_KEY env var overrides user config
  Given user config contains "api_keys:\n  openai: sk-file123"
  And environment variable "OPENAI_API_KEY" is "sk-env456"
  When I run "gitctx config get api_keys.openai --verbose"
  Then the output should contain "sk-...456"
  And the output should contain "(from OPENAI_API_KEY)"

Scenario: GITCTX env var overrides repo config
  Given repo config contains "search:\n  limit: 10"
  And environment variable "GITCTX_SEARCH__LIMIT" is "30"
  When I run "gitctx config get search.limit"
  Then the output should contain "30"
  And the output should contain "(from GITCTX_SEARCH__LIMIT)"

Scenario: config list default mode hides sources for defaults (terse)
  Given user config contains "api_keys:\n  openai: sk-test123"
  And repo config contains "search:\n  limit: 20"
  When I run "gitctx config list"
  Then the output should contain "api_keys.openai=sk-...123 (from user config)"
  And the output should contain "search.limit=20 (from repo config)"
  And the output should contain "model.embedding=text-embedding-3-large"
  And the output should NOT contain "(default)"

Scenario: config list verbose mode shows all sources
  Given user config contains "api_keys:\n  openai: sk-test123"
  When I run "gitctx config list --verbose"
  Then the output should contain "api_keys.openai=sk-...123 (from user config)"
  And the output should contain "model.embedding=text-embedding-3-large (default)"
  And the output should contain "search.limit=10 (default)"

Scenario: config set default mode shows terse confirmation
  Given I run "gitctx config init"
  When I run "gitctx config set search.limit 20"
  Then the exit code should be 0
  And the output should be exactly "set search.limit"
  And the file ".gitctx/config.yml" should contain "search:"
  And the file ".gitctx/config.yml" should contain "limit: 20"
  And the file "~/.gitctx/config.yml" should NOT contain "search"

Scenario: config set quiet mode suppresses output
  Given I run "gitctx config init"
  When I run "gitctx config set search.limit 20 --quiet"
  Then the exit code should be 0
  And the output should be empty
  And the file ".gitctx/config.yml" should contain "search:"
  And the file ".gitctx/config.yml" should contain "limit: 20"

Scenario: config set api key persists to user config
  When I run "gitctx config set api_keys.openai sk-test456"
  Then the exit code should be 0
  And the file "~/.gitctx/config.yml" should exist
  And the file "~/.gitctx/config.yml" should contain "api_keys:"
  And the file "~/.gitctx/config.yml" should contain "openai:"
  And the file "~/.gitctx/config.yml" should contain "sk-test456"
  And the file ".gitctx/config.yml" should NOT contain "sk-test456"
  And the file ".gitctx/config.yml" should NOT contain "api_keys"

Scenario: Config validation catches invalid values
  Given I run "gitctx config init"
  When I run "gitctx config set search.limit invalid"
  Then the exit code should be 2
  And the output should contain "validation error"

Scenario: Repo config is safe to commit (no secrets)
  Given I run "gitctx config init"
  And I run "gitctx config set search.limit 20"
  And I run "gitctx config set api_keys.openai sk-secret123"
  Then the file ".gitctx/config.yml" should contain "search:"
  And the file ".gitctx/config.yml" should contain "limit: 20"
  And the file ".gitctx/config.yml" should NOT contain "sk-"
  And the file ".gitctx/config.yml" should NOT contain "api_keys"
  And the file "~/.gitctx/config.yml" should contain "api_keys:"
  And the file "~/.gitctx/config.yml" should contain "sk-secret123"

Scenario: Malformed YAML file shows clear error
  Given repo config contains invalid YAML "search:\n  limit: [unclosed"
  When I run "gitctx config get search.limit"
  Then the exit code should be 1
  And the output should contain "Failed to parse config file"

Scenario: Permission denied on config save shows clear error
  Given repo config file exists with read-only permissions
  When I run "gitctx config set search.limit 30"
  Then the exit code should be 6
  And the output should contain "Permission denied"

Scenario: First-run tip appears once for config command
  When I run "gitctx config init"
  Then the output should contain "Tip"
  And the output should contain "API keys are stored securely"
  When I run "gitctx config init" in a new directory
  Then the output should NOT contain "Tip"

Scenario: Platform symbols use fallback on Windows cmd.exe
  When I run "gitctx config init" on Windows legacy terminal
  Then the output should contain "[OK]"
  And the output should NOT contain "✓"
```

## Step Definitions Implementation

Add to `tests/e2e/steps/cli_steps.py`:

**CRITICAL REUSE REQUIREMENTS**:

1. **context fixture ALREADY EXISTS** - DO NOT CREATE A NEW ONE!
   - Location: `tests/e2e/steps/cli_steps.py:13-15`
   - Just import and use it in your new step definitions
   - Creating a duplicate will cause pytest fixture conflicts

2. **`.gitctx/` directory ALREADY EXISTS** in fixtures:
   - `temp_home` already creates `.gitctx/` (conftest.py:79)
   - `e2e_git_isolation_env["HOME"]` already has `.gitctx/`
   - **DO NOT** call `mkdir()` for `.gitctx/` - it's redundant!

3. **6 step definitions ALREADY EXIST** - REUSE THEM:
   - `@when('I run "{command}"')` - EXISTS, don't recreate
   - `@then('the output should contain "{text}"')` - EXISTS
   - `@then('the output should not contain "{text}"')` - EXISTS
   - `@then("the exit code should be 0")` - EXISTS
   - `@then("the exit code should be {code:d}")` - EXISTS
   - `@then("the exit code should not be 0")` - EXISTS

4. **run_command step** - ENHANCE, don't replace:
   - Existing implementation in cli_steps.py:26-58
   - Add support for `context["custom_env"]` and `e2e_env_factory`
   - Don't rewrite the subprocess logic

```python
from pathlib import Path
from typing import Any
import yaml
from pytest_bdd import given, then, parsers

@given(parsers.parse('user config contains "{content}"'))
def setup_user_config(e2e_git_isolation_env: dict[str, str], content: str) -> None:
    """Create user config file with specified YAML content in isolated HOME.

    CRITICAL: e2e_git_isolation_env["HOME"] already has .gitctx/ directory!
    DO NOT call mkdir() - it's redundant and already exists.
    """
    home = Path(e2e_git_isolation_env["HOME"])
    config_path = home / ".gitctx" / "config.yml"
    # .gitctx/ already exists - just write the file
    config_path.write_text(content.replace('\\n', '\n'))

@given(parsers.parse('repo config contains "{content}"'))
def setup_repo_config(content: str) -> None:
    """Create repo config file with specified YAML content in current directory.

    Creates .gitctx/config.yml in the current working directory (test repo).
    """
    config_path = Path(".gitctx")
    config_path.mkdir(exist_ok=True)
    (config_path / "config.yml").write_text(content.replace('\\n', '\n'))

@given(parsers.parse('environment variable "{var}" is "{value}"'))
def setup_env_var(context: dict[str, Any], var: str, value: str) -> None:
    """Set environment variable for next command execution.

    CRITICAL: Stores in context["custom_env"] for run_command to use.
    This is necessary because monkeypatch doesn't work in subprocess contexts.

    The run_command step will check for context["custom_env"] and use
    e2e_env_factory to create an environment with these vars.
    """
    if "custom_env" not in context:
        context["custom_env"] = {}
    context["custom_env"][var] = value

@given(parsers.parse('repo config file exists with read-only permissions'))
def setup_readonly_repo_config() -> None:
    """Create read-only repo config file for testing permission errors."""
    config_path = Path(".gitctx")
    config_path.mkdir(exist_ok=True)
    config_file = config_path / "config.yml"
    config_file.write_text("search:\n  limit: 10\n")
    config_file.chmod(0o444)  # Read-only

@given(parsers.parse('repo config contains invalid YAML "{content}"'))
def setup_invalid_yaml_repo_config(content: str) -> None:
    """Create repo config with invalid YAML for error testing."""
    config_path = Path(".gitctx")
    config_path.mkdir(exist_ok=True)
    (config_path / "config.yml").write_text(content.replace('\\n', '\n'))

@then(parsers.parse('the file "{path}" should exist'))
def check_file_exists(e2e_git_isolation_env: dict[str, str], path: str) -> None:
    """Verify file exists at specified path.

    Handles both absolute paths and ~ expansion (to isolated HOME).
    """
    if path.startswith("~"):
        home = Path(e2e_git_isolation_env["HOME"])
        expanded = home / path[2:]  # Skip "~/"
    else:
        expanded = Path(path)

    assert expanded.exists(), f"File not found at {expanded}"

@then(parsers.parse('the file "{path}" should contain "{content}"'))
def check_file_contains(e2e_git_isolation_env: dict[str, str], path: str, content: str) -> None:
    """Verify file contains specified content."""
    if path.startswith("~"):
        home = Path(e2e_git_isolation_env["HOME"])
        expanded = home / path[2:]
    else:
        expanded = Path(path)

    assert expanded.exists(), f"File not found at {expanded}"
    file_content = expanded.read_text()
    assert content in file_content, f"Expected '{content}' in {path}, got: {file_content}"

@then(parsers.parse('the file "{path}" should NOT contain "{content}"'))
def check_file_not_contains(e2e_git_isolation_env: dict[str, str], path: str, content: str) -> None:
    """Verify file does NOT contain specified content."""
    if path.startswith("~"):
        home = Path(e2e_git_isolation_env["HOME"])
        expanded = home / path[2:]
    else:
        expanded = Path(path)

    if not expanded.exists():
        return  # File doesn't exist, so it doesn't contain the content

    file_content = expanded.read_text()
    assert content not in file_content, f"Did not expect '{content}' in {path}, got: {file_content}"

@then(parsers.parse('the user config file should exist at "{path}"'))
def check_user_config_exists(e2e_git_isolation_env: dict[str, str], path: str) -> None:
    """Verify user config file exists (alias for better readability in scenarios)."""
    check_file_exists(e2e_git_isolation_env, path)

@then(parsers.parse('"{filename}" should contain "{content}"'))
def check_gitignore_content(filename: str, content: str) -> None:
    """Verify .gitctx/.gitignore contains expected content."""
    file_path = Path(".gitctx") / filename.replace(".gitctx/", "")
    assert file_path.exists(), f"File not found: {file_path}"
    file_content = file_path.read_text()
    assert content in file_content, f"Expected '{content}' in {file_path}"
```

## Unit Tests Detail

Create `tests/unit/core/test_config.py`:

**CRITICAL**: Use `temp_home` fixture which **already creates `.gitctx/` directory**!

```python
"""Unit tests for Pydantic Settings configuration."""

import os
from pathlib import Path
import pytest
from pydantic import ValidationError

# Will fail - module doesn't exist yet
from gitctx.core.config import GitCtxSettings, ApiKeys, SearchSettings


class TestConfigLoading:
    """Test configuration loading from various sources."""

    def test_config_loads_from_yaml(self, temp_home, monkeypatch):
        """Config should load settings from YAML file.

        NOTE: temp_home already has .gitctx/ subdirectory created!
        """
        # Setup - override Path.home() to return temp_home
        monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)

        # Write config (temp_home / ".gitctx" already exists!)
        config_file = temp_home / ".gitctx" / "config.yml"
        config_file.write_text("api_keys:\n  openai: sk-file123\n")

        # Act
        settings = GitCtxSettings()

        # Assert - will FAIL (no implementation)
        assert settings.api_keys.openai.get_secret_value() == "sk-file123"

    def test_provider_env_var_highest_precedence(self, temp_home, monkeypatch):
        """OPENAI_API_KEY should override all other sources."""
        # Setup - override Path.home() and set env vars
        monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)
        monkeypatch.setenv("GITCTX_API_KEYS__OPENAI", "sk-gitctx456")
        monkeypatch.setenv("OPENAI_API_KEY", "sk-provider789")

        # Write config (temp_home / ".gitctx" already exists!)
        config_file = temp_home / ".gitctx" / "config.yml"
        config_file.write_text("api_keys:\n  openai: sk-file123\n")

        # Act
        settings = GitCtxSettings()

        # Assert - will FAIL (OPENAI_API_KEY wins)
        assert settings.api_keys.openai.get_secret_value() == "sk-provider789"

    def test_gitctx_env_var_overrides_yaml(self, temp_home, monkeypatch):
        """GITCTX_API_KEYS__OPENAI should override YAML."""
        # Setup
        monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)
        monkeypatch.setenv("GITCTX_API_KEYS__OPENAI", "sk-gitctx456")

        # Write config (temp_home / ".gitctx" already exists!)
        config_file = temp_home / ".gitctx" / "config.yml"
        config_file.write_text("api_keys:\n  openai: sk-file123\n")

        # Act
        settings = GitCtxSettings()

        # Assert - will FAIL (env var wins)
        assert settings.api_keys.openai.get_secret_value() == "sk-gitctx456"

    def test_yaml_used_when_no_env_vars(self, temp_home, monkeypatch):
        """YAML should be used when no env vars are set."""
        # Setup
        monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)

        # Write config (temp_home / ".gitctx" already exists!)
        config_file = temp_home / ".gitctx" / "config.yml"
        config_file.write_text("api_keys:\n  openai: sk-file123\n")

        # Act
        settings = GitCtxSettings()

        # Assert - will FAIL
        assert settings.api_keys.openai.get_secret_value() == "sk-file123"


class TestConfigValidation:
    """Test Pydantic validation of configuration values."""

    def test_config_validates_types(self):
        """Config should validate type correctness."""
        # Act
        settings = GitCtxSettings(search={"limit": 20})

        # Assert - will FAIL
        assert settings.search.limit == 20
        assert isinstance(settings.search.limit, int)

    def test_config_rejects_invalid_types(self):
        """Config should reject invalid type values."""
        # Assert - will FAIL
        with pytest.raises(ValidationError) as exc_info:
            GitCtxSettings(search={"limit": "invalid"})

        assert "validation error" in str(exc_info.value).lower()

    def test_secret_str_masks_api_keys(self):
        """SecretStr should mask API keys in string representation."""
        # Act
        api_keys = ApiKeys(openai="sk-test123456")

        # Assert - will FAIL
        assert "sk-test123456" not in str(api_keys)
        assert api_keys.openai.get_secret_value() == "sk-test123456"


class TestConfigPersistence:
    """Test saving and loading configuration."""

    def test_config_saves_to_yaml(self, temp_home, monkeypatch):
        """Config.save() should persist to YAML file.

        NOTE: temp_home already has .gitctx/ directory!
        """
        # Setup
        monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)
        settings = GitCtxSettings()
        settings.api_keys.openai = "sk-test123"

        # Act
        settings.save()

        # Assert - will FAIL
        config_file = temp_home / ".gitctx" / "config.yml"
        assert config_file.exists()
        content = config_file.read_text()
        assert "openai" in content

    def test_config_directory_already_exists(self, temp_home, monkeypatch):
        """Config should work when ~/.gitctx/ already exists.

        NOTE: temp_home fixture already creates this directory!
        """
        # Setup
        monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)

        # Verify directory exists (created by temp_home fixture)
        assert (temp_home / ".gitctx").exists()
        assert (temp_home / ".gitctx").is_dir()

        # Act - save should work even with existing directory
        settings = GitCtxSettings()
        settings.save()

        # Assert - will FAIL
        assert (temp_home / ".gitctx" / "config.yml").exists()

    def test_config_handles_missing_file(self, temp_home, monkeypatch):
        """Config should use defaults when YAML file doesn't exist.

        NOTE: temp_home has .gitctx/ directory but no config.yml file.
        """
        # Setup
        monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)

        # Act
        settings = GitCtxSettings()

        # Assert - will FAIL (should use defaults)
        assert settings.search.limit == 10  # default
        assert settings.model.embedding == "text-embedding-3-large"  # default
```

## Acceptance Criteria

- [x] All BDD scenarios written and added to `cli.feature` (19 new scenarios)
- [x] All step definitions implemented (11 new step definitions)
- [x] All unit tests written (33 tests covering all scenarios)
- [x] Run `uv run pytest` - **all tests FAIL/SKIP** (RED phase) - 19 failed, 33 skipped ✅
- [x] Test coverage plan documented and meets 85%+ target
- [x] Tests clearly document expected behavior

## TDD Requirements

**This is the RED phase** - tests must:
1. Be written before implementation
2. Fail when run (proving they test real behavior)
3. Document expected behavior clearly
4. Cover all acceptance criteria from parent story

## Testing Commands

```bash
# Run BDD tests (should FAIL)
uv run pytest tests/e2e/ -k config -v

# Run unit tests (should FAIL)
uv run pytest tests/unit/core/test_config.py -v

# Run all tests (should show FAILures)
uv run pytest -v

# Check coverage plan
uv run pytest --cov=src/gitctx/core/config --cov-report=term-missing
```

## Implementation Notes

### Enhancing run_command Step

The existing `run_command` step in `tests/e2e/steps/cli_steps.py` needs a small enhancement to support custom env vars from `context["custom_env"]`:

```python
@when(parsers.parse('I run "{command}"'))
def run_command(
    command: str,
    e2e_git_isolation_env: dict[str, str],
    e2e_env_factory,
    context: dict[str, Any]
) -> None:
    """
    Execute a CLI command as subprocess with full isolation.

    CRITICAL: Uses subprocess.run() with isolated environment to ensure
    true isolation from developer SSH keys, GPG keys, and git config.

    Enhancement: Checks context["custom_env"] for custom environment variables
    set by previous @given steps (e.g., OPENAI_API_KEY, GITCTX_*).
    """
    # Check if custom env vars were set by previous @given steps
    if "custom_env" in context:
        env = e2e_env_factory(**context["custom_env"])
        # Clear for next scenario
        context.pop("custom_env")
    else:
        env = e2e_git_isolation_env

    # Parse the command and convert gitctx to python -m gitctx
    # (rest of implementation unchanged)
    if command.startswith("gitctx"):
        args = command.replace("gitctx", "").strip().split() if command.strip() != "gitctx" else []
        cmd_parts = [sys.executable, "-m", "gitctx"] + args
    else:
        cmd_parts = command.strip().split()

    # Run gitctx as subprocess with full isolation
    result = subprocess.run(
        cmd_parts,
        env=env,  # Now uses custom env if provided
        capture_output=True,
        text=True,
    )

    context["result"] = result
    context["output"] = result.stdout
    context["exit_code"] = result.returncode
```

### Fixture Usage Summary

**Use existing fixtures** - NO new fixtures needed:

- `e2e_git_isolation_env` - Provides isolated HOME with `.gitctx/` already created
- `e2e_env_factory` - Creates custom environments with additional env vars
- `context` - **Already exists!** Stores data between steps

**Key Pattern**:
1. `@given` steps write to `context["custom_env"]`
2. `@when` step (`run_command`) reads from `context["custom_env"]` and uses `e2e_env_factory`
3. `@then` steps read from `context["output"]`, `context["exit_code"]`

## Notes

- **RED phase**: Tests should fail because `src/gitctx/core/config.py` doesn't exist
- **Next task**: TASK-0001.1.2.2 will make these tests pass (GREEN)
- Import errors are expected - they prove we're testing first
- **Fixture pattern**: Use `e2e_git_isolation_env` for HOME (already has `.gitctx/`!)
- **Env vars in E2E**: Store in `context["custom_env"]` for `e2e_env_factory`
- **Test isolation**: All fixtures follow patterns in `tests/conftest.py` and `tests/e2e/conftest.py`
- **`context` fixture exists**: Defined in `tests/e2e/steps/cli_steps.py`, just use it!

## Dependencies

- Parent story created
- `tests/e2e/features/cli.feature` exists
- `tests/e2e/step_defs/test_cli.py` exists
- pytest-bdd framework working (from STORY-0001.1.0)

---

**Created**: 2025-10-04
**Last Updated**: 2025-10-04
