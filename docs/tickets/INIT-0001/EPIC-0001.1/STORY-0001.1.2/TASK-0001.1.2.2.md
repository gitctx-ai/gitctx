# TASK-0001.1.2.2: Implement User and Repo Config with Pydantic Settings

**Parent Story**: [STORY-0001.1.2](README.md)
**Status**: ✅ Complete
**Estimated Hours**: 1.0
**Actual Hours**: 1.0

## Description

**GREEN Phase** - Implement user and repo configuration using Pydantic Settings to make all tests from TASK-0001.1.2.1 pass.

This task creates the production-quality configuration system with:
- Separate UserConfig and RepoConfig classes for security
- Type-safe configuration using Pydantic models
- Multi-source loading (YAML, environment variables, defaults)
- User precedence: OPENAI_API_KEY > user YAML
- Repo precedence: GITCTX_* env > repo YAML
- Automatic API key masking with SecretStr
- YAML file persistence to appropriate locations
- Config init functionality for repo setup

## Implementation Checklist

### Dependencies

**CRITICAL**: `pyyaml>=6.0.1` **ALREADY EXISTS** in pyproject.toml:30! DO NOT add it again!

- [x] Add **ONLY** these to `pyproject.toml` dependencies:
  ```toml
  dependencies = [
      # ...existing dependencies (typer, rich, pyyaml, shellingham)...
      "pydantic>=2.11.0",
      "pydantic-settings[yaml]>=2.11.0",  # [yaml] extra for YAML support
  ]
  ```
- [x] Run `uv sync` to install new dependencies
- [x] Verify installation: `uv run python -c "import pydantic_settings; print(pydantic_settings.__version__)"`

**Note**: YAML parsing via `import yaml` will work immediately - pyyaml is already installed!

### Core Implementation

- [x] Create `src/gitctx/core/user_config.py` with:
  - [x] `ApiKeys` model (BaseModel) - only openai field
  - [x] `ProviderEnvSource` custom source for OPENAI_API_KEY
  - [x] `UserConfig` (BaseSettings) with only api_keys field
  - [x] `save()` method → `~/.gitctx/config.yml`
- [x] Create `src/gitctx/core/repo_config.py` with:
  - [x] `SearchSettings`, `IndexSettings`, `ModelSettings` models
  - [x] `RepoConfig` (BaseSettings) with search, index, model fields
  - [x] `save()` method → `.gitctx/config.yml`
- [x] Create `src/gitctx/core/config.py` with:
  - [x] `GitCtxSettings` aggregator class
  - [x] `get(key)` method with routing logic
  - [x] `set(key, value)` method with routing logic
  - [x] `get_source(key)` method for source indicators
  - [x] `init_repo_config()` function

### Precedence Implementation

- [x] Implement user config precedence:
  1. `init_settings` - Direct initialization (highest)
  2. `ProviderEnvSource` - OPENAI_API_KEY env var
  3. `YamlConfigSettingsSource` - user YAML file
  4. Field defaults (lowest)
- [x] Implement repo config precedence:
  1. `init_settings` - Direct initialization (highest)
  2. `env_settings` - GITCTX_* env vars
  3. `YamlConfigSettingsSource` - repo YAML file
  4. Field defaults (lowest)

### File Persistence

- [x] Implement `UserConfig.save()` method:
  - [x] Create `~/.gitctx/` directory if missing
  - [x] Serialize api_keys to YAML
  - [x] Handle SecretStr properly (reveal for saving)
  - [x] Write to `~/.gitctx/config.yml`
  - [x] Set file permissions (0600 - user only)
- [x] Implement `RepoConfig.save()` method:
  - [x] Create `.gitctx/` directory if missing
  - [x] Serialize search, index, model to YAML
  - [x] Write to `.gitctx/config.yml`
  - [x] Set file permissions (0644 - safe to commit)
- [x] Implement `init_repo_config()` function:
  - [x] Create `.gitctx/` directory
  - [x] Create `.gitctx/config.yml` with defaults
  - [x] Create `.gitctx/.gitignore` with db/, logs/, *.log

### Validation and Error Handling

- [x] Add type validation for all settings
- [x] Add custom validators if needed (e.g., positive integers)
- [x] Ensure helpful error messages for validation failures
- [x] Add error handling for malformed YAML files (catch yaml.YAMLError, show "Failed to parse config file")
- [x] Add error handling for permission denied errors (catch PermissionError, show "Permission denied")
- [x] Ensure error messages are clear and actionable

## Code Implementation

**Three separate files for security separation:**

### File 1: Create `src/gitctx/core/user_config.py`

**Platform Compatibility Note**: `Path.home()` is cross-platform compatible (works on Windows, macOS, Linux). On Windows, it resolves to `C:\Users\<username>`, on Unix-like systems to `/home/<username>` or `/Users/<username>`. The pathlib library handles platform-specific path separators automatically.

**Testing Note**: Unit tests use the `temp_home` fixture which **already creates the `.gitctx/` subdirectory**. Override `Path.home()` with `monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)` in tests.

```python
"""User-level configuration (API keys only)."""
from pathlib import Path
from typing import Any
import os

import yaml
from pydantic import BaseModel, Field, SecretStr
from pydantic_settings import (
    BaseSettings,
    SettingsConfigDict,
    PydanticBaseSettingsSource,
    YamlConfigSettingsSource,
)


class ApiKeys(BaseModel):
    """API key configuration."""
    openai: SecretStr | None = Field(default=None, description="OpenAI API key")


class ProviderEnvSource(PydanticBaseSettingsSource):
    """Custom source for OPENAI_API_KEY env var."""

    def get_field_value(self, field, field_name):
        # Not used - only __call__ is invoked
        raise NotImplementedError()

    def __call__(self) -> dict[str, Any]:
        d = {}
        if openai_key := os.getenv("OPENAI_API_KEY"):
            d["api_keys"] = {"openai": openai_key}
        return d


class UserConfig(BaseSettings):
    """User config (~/.gitctx/config.yml) - API keys only.

    Precedence:
    1. OPENAI_API_KEY env var (highest)
    2. User YAML file
    3. Defaults
    """
    api_keys: ApiKeys = Field(default_factory=ApiKeys)

    model_config = SettingsConfigDict(
        yaml_file=str(Path.home() / ".gitctx" / "config.yml"),
        case_sensitive=False,
        validate_default=True,
    )

    @classmethod
    def settings_customise_sources(cls, settings_cls, init_settings, env_settings, dotenv_settings, file_secret_settings):
        return (
            init_settings,
            ProviderEnvSource(settings_cls),  # OPENAI_API_KEY
            YamlConfigSettingsSource(settings_cls),
        )

    def save(self) -> None:
        """Save API keys to user config file."""
        config_path = Path.home() / ".gitctx" / "config.yml"
        config_path.parent.mkdir(parents=True, exist_ok=True)

        data = {}
        if self.api_keys.openai is not None:
            data["api_keys"] = {"openai": self.api_keys.openai.get_secret_value()}

        # Secure permissions
        old_umask = os.umask(0o077)
        try:
            with config_path.open("w") as f:
                yaml.dump(data, f, default_flow_style=False)
        finally:
            os.umask(old_umask)
        config_path.chmod(0o600)
```

### File 2: Create `src/gitctx/core/repo_config.py`

```python
"""Repo-level configuration (team settings only)."""
from pathlib import Path
import os

import yaml
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class SearchSettings(BaseModel):
    limit: int = Field(default=10, gt=0, le=100)
    rerank: bool = True


class IndexSettings(BaseModel):
    chunk_size: int = Field(default=1000, gt=0)
    chunk_overlap: int = Field(default=200, ge=0)


class ModelSettings(BaseModel):
    embedding: str = "text-embedding-3-large"


class RepoConfig(BaseSettings):
    """Repo config (.gitctx/config.yml) - team settings only.

    Precedence:
    1. GITCTX_* env vars (highest)
    2. Repo YAML file
    3. Defaults

    Default YAML content (created by config init):
    ```yaml
    search:
      limit: 10
      rerank: true
    index:
      chunk_size: 1000
      chunk_overlap: 200
    model:
      embedding: text-embedding-3-large
    ```
    """
    search: SearchSettings = Field(default_factory=SearchSettings)
    index: IndexSettings = Field(default_factory=IndexSettings)
    model: ModelSettings = Field(default_factory=ModelSettings)

    model_config = SettingsConfigDict(
        yaml_file=".gitctx/config.yml",
        env_prefix="GITCTX_",
        env_nested_delimiter="__",
        case_sensitive=False,
    )

    def save(self) -> None:
        """Save team settings to repo config file."""
        config_path = Path(".gitctx/config.yml")
        config_path.parent.mkdir(parents=True, exist_ok=True)

        data = {
            "search": self.search.model_dump(),
            "index": self.index.model_dump(),
            "model": self.model.model_dump(),
        }

        with config_path.open("w") as f:
            yaml.dump(data, f, default_flow_style=False)
        config_path.chmod(0o644)  # Safe to commit
```

### File 3: Create `src/gitctx/core/config.py`

```python
"""Aggregates user and repo config with smart routing."""
from pathlib import Path
from typing import Any
import os

import yaml
from .user_config import UserConfig
from .repo_config import RepoConfig


class GitCtxSettings:
    """Aggregator that routes config by key pattern.

    Routes:
    - api_keys.* → UserConfig (~/.gitctx/config.yml)
    - search.*, index.*, model.* → RepoConfig (.gitctx/config.yml)
    """

    def __init__(self):
        self.user = UserConfig()
        self.repo = RepoConfig()

    def get(self, key: str) -> Any:
        """Get config value, routing by key pattern."""
        if key.startswith("api_keys."):
            return self._get_from_user(key)
        else:
            return self._get_from_repo(key)

    def _get_from_user(self, key: str) -> Any:
        """Get value from user config."""
        parts = key.split(".")
        current = self.user
        for part in parts:
            current = getattr(current, part, None)
            if current is None:
                return None

        # Handle SecretStr
        if hasattr(current, "get_secret_value"):
            return current.get_secret_value()
        return current

    def _get_from_repo(self, key: str) -> Any:
        """Get value from repo config."""
        parts = key.split(".")
        current = self.repo
        for part in parts:
            current = getattr(current, part, None)
            if current is None:
                return None
        return current

    def set(self, key: str, value: Any) -> None:
        """Set config value, routing by key pattern."""
        if key.startswith("api_keys."):
            self._set_in_user(key, value)
            self.user.save()  # → ~/.gitctx/config.yml
        else:
            self._set_in_repo(key, value)
            self.repo.save()  # → .gitctx/config.yml

    def _set_in_user(self, key: str, value: Any) -> None:
        """Set value in user config."""
        parts = key.split(".")
        current = self.user
        for part in parts[:-1]:
            current = getattr(current, part)
        setattr(current, parts[-1], value)

    def _set_in_repo(self, key: str, value: Any) -> None:
        """Set value in repo config."""
        parts = key.split(".")
        current = self.repo
        for part in parts[:-1]:
            current = getattr(current, part)
        setattr(current, parts[-1], value)

    def get_source(self, key: str) -> str:
        """Get the source of a configuration value."""
        if key.startswith("api_keys."):
            # Check OPENAI_API_KEY
            if key == "api_keys.openai" and os.getenv("OPENAI_API_KEY"):
                return "(from OPENAI_API_KEY)"

            # Check user config file
            user_config_path = Path.home() / ".gitctx" / "config.yml"
            if user_config_path.exists():
                try:
                    with user_config_path.open() as f:
                        config_data = yaml.safe_load(f) or {}
                    if "api_keys" in config_data:
                        return "(from user config)"
                except Exception:
                    pass
        else:
            # Check GITCTX_* env vars
            env_key = f"GITCTX_{key.upper().replace('.', '__')}"
            if os.getenv(env_key):
                return f"(from {env_key})"

            # Check repo config file
            repo_config_path = Path(".gitctx/config.yml")
            if repo_config_path.exists():
                try:
                    with repo_config_path.open() as f:
                        config_data = yaml.safe_load(f) or {}
                    # Navigate nested dict
                    parts = key.split(".")
                    current = config_data
                    for part in parts:
                        if isinstance(current, dict) and part in current:
                            current = current[part]
                        else:
                            return "(default)"
                    return "(from repo config)"
                except Exception:
                    pass

        return "(default)"


def init_repo_config() -> None:
    """Initialize .gitctx/ structure."""
    gitctx_dir = Path(".gitctx")
    gitctx_dir.mkdir(exist_ok=True)

    # Create config.yml
    config_file = gitctx_dir / "config.yml"
    if not config_file.exists():
        RepoConfig().save()

    # Create .gitignore
    gitignore_content = """# LanceDB vector database - never commit
db/

# Application logs - never commit
logs/
*.log
"""
    (gitctx_dir / ".gitignore").write_text(gitignore_content)
```

## Testing Requirements

**CRITICAL**: Use existing fixtures from `tests/conftest.py`:

### Fixture Usage Patterns

**For unit tests** - Use `temp_home` fixture:

```python
def test_user_config_saves_with_permissions(temp_home, monkeypatch):
    """Test that user config saves with correct 0600 permissions.

    Uses temp_home fixture which already has .gitctx/ directory created.
    """
    # Override Path.home() to use temp_home
    monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)

    # Create and save config
    from gitctx.core.user_config import UserConfig
    user_config = UserConfig()
    user_config.api_keys.openai = "sk-test123"
    user_config.save()

    # Verify file exists (temp_home / ".gitctx" already exists!)
    config_file = temp_home / ".gitctx" / "config.yml"
    assert config_file.exists()

    # Check permissions
    import stat
    mode = config_file.stat().st_mode
    assert stat.S_IMODE(mode) == 0o600
```

**For environment variable testing** - Use `monkeypatch`:

```python
def test_openai_api_key_env_precedence(temp_home, monkeypatch):
    """Test that OPENAI_API_KEY env var overrides user config YAML.

    Uses monkeypatch for env vars and temp_home for file system isolation.
    """
    # Setup
    monkeypatch.setattr("pathlib.Path.home", lambda: temp_home)
    monkeypatch.setenv("OPENAI_API_KEY", "sk-env-override")

    # Write config with different value (temp_home / ".gitctx" already exists!)
    config_file = temp_home / ".gitctx" / "config.yml"
    config_file.write_text("api_keys:\n  openai: sk-from-file\n")

    # Test
    from gitctx.core.user_config import UserConfig
    user_config = UserConfig()

    # OPENAI_API_KEY should win
    assert user_config.api_keys.openai.get_secret_value() == "sk-env-override"
```

**For repo config testing** - Use current directory:

```python
def test_repo_config_saves_to_local_dir(tmp_path, monkeypatch):
    """Test that repo config saves to .gitctx/ in current directory.

    Uses tmp_path as working directory (NOT temp_home).
    """
    # Change to test directory
    import os
    monkeypatch.chdir(tmp_path)

    # Create and save repo config
    from gitctx.core.repo_config import RepoConfig
    repo_config = RepoConfig()
    repo_config.search.limit = 25
    repo_config.save()

    # Verify saved to current directory
    config_file = tmp_path / ".gitctx" / "config.yml"
    assert config_file.exists()

    # Check content
    content = config_file.read_text()
    assert "limit: 25" in content
```

### After Implementation:

- [x] Run unit tests: `uv run pytest tests/unit/core/test_config.py -v`
  - All 36 core tests PASSING (GREEN) ✅
- [x] Run BDD tests: `uv run pytest tests/e2e/ -k config -v`
  - Config persistence scenarios PASSING ✅
  - Precedence scenarios PASSING ✅
  - Validation scenarios PASSING ✅
- [x] Check coverage: `uv run pytest --cov=src/gitctx/core/config --cov-report=term-missing`
  - user_config: 100%, repo_config: 100%, config: 90.77% ✅

### Available Fixtures:

From `tests/conftest.py`:
- **`temp_home`** - Isolated HOME with `.gitctx/` already created (use for user config)
- **`git_isolation_base`** - Security isolation env vars
- **`cli_runner`** - In-process CLI runner for quick tests

From `tests/e2e/conftest.py`:
- **`e2e_git_isolation_env`** - Complete subprocess environment
- **`e2e_env_factory`** - Custom environment factory
- **`e2e_cli_runner`** - Subprocess CLI runner
- **`e2e_git_repo`** - Real git repository

## Refactoring Opportunities

After tests pass (GREEN), consider:

- [x] Extract YAML serialization to helper function (deferred - current implementation is clean)
- [x] Add more custom validators if needed (Field validators with gt, ge, le sufficient)
- [x] Optimize file I/O (caching, lazy loading) (deferred - performance meets targets)
- [ ] Add config migration utilities for future versions (YAGNI - defer to future story)

## Acceptance Criteria

- [x] All unit tests from TASK-0001.1.2.1 pass
- [x] All BDD scenarios pass
- [x] Type validation works (invalid values rejected)
- [x] YAML file persistence works (save and load)
- [x] Three-tier precedence implemented correctly
- [x] SecretStr masks API keys automatically
- [x] File permissions set correctly (0600 user, 0644 repo)
- [x] Coverage ≥ 85% (actual: user_config 100%, repo_config 100%, config 90.77%)
- [x] No regressions in existing tests

## Testing Commands

```bash
# Install dependencies
uv sync

# Run unit tests
uv run pytest tests/unit/core/test_config.py -vvs

# Run BDD tests
uv run pytest tests/e2e/ -k config -vvs

# Run all tests
uv run pytest -v

# Check coverage
uv run pytest tests/unit/core/test_config.py --cov=src/gitctx/core/config --cov-report=term-missing

# Manual testing
uv run python -c "from gitctx.core.config import GitCtxSettings; s = GitCtxSettings(); print(s)"
```

## Notes

- **GREEN phase**: Make all RED tests pass
- Use Pydantic's built-in validation (don't reinvent)
- SecretStr automatically masks in logs/repr
- File permissions important for security (API keys)
- `get_source()` helper enables source indicators in CLI
- YAML library already in dependencies (pyyaml>=6.0.1)

## Dependencies

- [ ] TASK-0001.1.2.1 complete (tests written and failing)
- [ ] `pydantic>=2.11.0` installed
- [ ] `pydantic-settings>=2.11.0` installed
- [ ] Parent story created

## Security Considerations

- [ ] API keys masked in string representations (SecretStr)
- [ ] Config file has restrictive permissions (0600)
- [ ] No secrets in logs or error messages
- [ ] Validation prevents injection attacks

---

**Created**: 2025-10-04
**Last Updated**: 2025-10-04
