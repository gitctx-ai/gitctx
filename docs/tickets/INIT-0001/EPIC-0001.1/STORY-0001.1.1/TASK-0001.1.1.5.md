# TASK-0001.1.1.5: Add Error Handling & Validation

**Parent Story**: [STORY-0001.1.1](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 2
**Actual Hours**: -

## Description

Implement comprehensive error handling and validation across all CLI commands. This includes handling invalid commands, missing arguments, and providing helpful error messages with suggestions. Also enhance the main CLI with Rich console formatting for consistent, beautiful output.

## Implementation Checklist

- [ ] Add custom exception handler to main app
- [ ] Implement "did you mean?" suggestions for typos
- [ ] Handle missing required arguments gracefully
- [ ] Add validation for command arguments
- [ ] Implement consistent error formatting with Rich
- [ ] Add command aliases for common typos
- [ ] Show helpful context in error messages
- [ ] Enable BDD tests: "Invalid command", "Missing required arguments"
- [ ] Add unit tests for error scenarios
- [ ] Ensure all errors have actionable next steps

## TDD Requirements

### Test First (RED)

Write unit tests in `tests/unit/cli/test_error_handling.py`:

```python
import pytest
from typer.testing import CliRunner
from gitctx.cli.main import app

runner = CliRunner()

def test_invalid_command():
    """Verify invalid commands show helpful error."""
    result = runner.invoke(app, ["invalid"])
    assert result.exit_code != 0
    assert "invalid" in result.stdout.lower() or "unknown" in result.stdout.lower()
    assert "available commands" in result.stdout.lower() or "usage" in result.stdout.lower()

def test_invalid_command_suggestion():
    """Verify typos get suggestions."""
    result = runner.invoke(app, ["serach"])  # Typo of "search"
    assert result.exit_code != 0
    assert "did you mean" in result.stdout.lower() or "search" in result.stdout.lower()

def test_missing_required_argument():
    """Verify missing arguments show helpful error."""
    result = runner.invoke(app, ["search"])
    assert result.exit_code != 0
    assert "missing" in result.stdout.lower() or "required" in result.stdout.lower()
    assert "query" in result.stdout.lower()

def test_invalid_option_value():
    """Verify invalid option values are caught."""
    result = runner.invoke(app, ["search", "test", "--limit", "invalid"])
    assert result.exit_code != 0
    assert "invalid" in result.stdout.lower()
    assert "number" in result.stdout.lower() or "integer" in result.stdout.lower()

def test_help_suggestion_on_error():
    """Verify errors suggest using --help."""
    result = runner.invoke(app, ["search"])
    assert result.exit_code != 0
    assert "--help" in result.stdout or "help" in result.stdout.lower()

def test_config_invalid_subcommand():
    """Verify invalid subcommands show available options."""
    result = runner.invoke(app, ["config", "invalid"])
    assert result.exit_code != 0
    assert "invalid" in result.stdout.lower()
    assert "available" in result.stdout.lower() or "commands" in result.stdout.lower()

def test_empty_command():
    """Verify running without commands shows help."""
    result = runner.invoke(app, [])
    assert result.exit_code == 0
    assert "usage" in result.stdout.lower()
    assert "commands" in result.stdout.lower()

def test_version_error_handling():
    """Verify version flag works even with invalid commands."""
    result = runner.invoke(app, ["--version", "invalid"])
    assert result.exit_code == 0
    assert "gitctx version" in result.stdout

def test_clear_invalid_flag_combination():
    """Verify incompatible flags are caught."""
    # This is a mock test - implement actual validation
    result = runner.invoke(app, ["clear", "--invalid-flag"])
    assert result.exit_code != 0
    assert "invalid" in result.stdout.lower() or "unknown" in result.stdout.lower()

def test_search_limit_out_of_range():
    """Verify limit validation works."""
    result = runner.invoke(app, ["search", "test", "--limit", "0"])
    assert result.exit_code != 0
    assert "must be" in result.stdout.lower() or "range" in result.stdout.lower()
```

### Implementation (GREEN)

Update `src/gitctx/cli/main.py` with enhanced error handling:

```python
"""Main CLI application with enhanced error handling."""

import sys
from typing import Optional
import typer
from typer import Context
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from difflib import get_close_matches

from gitctx import __version__

# Create console for rich output
console = Console()

# Create app with Rich support and custom settings
app = typer.Typer(
    name="gitctx",
    help="Context optimization engine for coding workflows",
    add_completion=False,
    rich_markup_mode="rich",
    context_settings={
        "help_option_names": ["-h", "--help"],
        "max_content_width": 120,
    },
    pretty_exceptions_enable=False,  # We'll handle exceptions ourselves
)

# Available commands for suggestion matching
AVAILABLE_COMMANDS = ["index", "search", "config", "clear"]

class GitctxError(Exception):
    """Base exception for gitctx CLI errors."""
    pass

def version_callback(value: bool) -> None:
    """Show version and exit."""
    if value:
        console.print(f"[bold cyan]gitctx[/bold cyan] version {__version__}")
        raise typer.Exit()

def suggest_command(invalid_cmd: str) -> Optional[str]:
    """Suggest a command based on typo."""
    matches = get_close_matches(invalid_cmd, AVAILABLE_COMMANDS, n=1, cutoff=0.6)
    return matches[0] if matches else None

def show_error(message: str, suggestion: Optional[str] = None, context: Optional[str] = None) -> None:
    """Display a formatted error message."""
    error_text = Text()
    error_text.append("Error: ", style="bold red")
    error_text.append(message)

    panel_content = [error_text]

    if context:
        panel_content.append(Text())  # Empty line
        panel_content.append(Text(context, style="dim"))

    if suggestion:
        panel_content.append(Text())  # Empty line
        suggestion_text = Text()
        suggestion_text.append("ðŸ’¡ ", style="yellow")
        suggestion_text.append(suggestion, style="cyan")
        panel_content.append(suggestion_text)

    # Combine all text elements
    full_content = Text()
    for i, text in enumerate(panel_content):
        if i > 0:
            full_content.append("\n")
        full_content.append(text)

    panel = Panel(
        full_content,
        title="[bold red]Command Failed[/bold red]",
        border_style="red",
        padding=(1, 2),
    )
    console.print(panel)

@app.callback(invoke_without_command=True)
def main(
    ctx: Context,
    version: bool | None = typer.Option(
        None,
        "--version",
        callback=version_callback,
        is_eager=True,
        help="Show version and exit",
    ),
) -> None:
    """
    gitctx - Context optimization engine for coding workflows.

    Use gitctx to index and search your codebase with AI-powered context understanding.
    """
    # If no command is provided, show help
    if ctx.invoked_subcommand is None:
        console.print("[bold cyan]gitctx[/bold cyan] - Context optimization engine")
        console.print()
        console.print("Use [cyan]gitctx --help[/cyan] to see available commands")
        console.print()
        console.print("[bold]Quick start:[/bold]")
        console.print("  1. [cyan]gitctx config set api_keys.openai <your-key>[/cyan]")
        console.print("  2. [cyan]gitctx index[/cyan]")
        console.print("  3. [cyan]gitctx search \"your query\"[/cyan]")

# Custom exception handler
def exception_handler(exc_type, exc_value, exc_traceback):
    """Handle exceptions with nice formatting."""
    if exc_type == KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/yellow]")
        sys.exit(130)
    elif exc_type == typer.Exit:
        sys.exit(exc_value.exit_code)
    elif exc_type == typer.BadParameter:
        show_error(
            str(exc_value),
            suggestion="Use --help to see valid options",
        )
        sys.exit(1)
    elif exc_type == GitctxError:
        show_error(str(exc_value))
        sys.exit(1)
    else:
        # For unexpected errors, show more detail
        import traceback
        console.print("[bold red]Unexpected error:[/bold red]")
        console.print(traceback.format_exc())
        sys.exit(1)

# Install custom exception handler
sys.excepthook = exception_handler

# Register commands
from gitctx.cli import index, search, config, clear

index.register(app)
search.register(app)
config.register(app)
clear.register(app)

# Add command not found handler
original_process = app.process

def custom_process(argv=None):
    """Custom command processor with suggestions."""
    try:
        return original_process(argv)
    except SystemExit as e:
        # Check if it's a command not found error
        if argv and len(argv) > 0:
            cmd = argv[0]
            if cmd not in AVAILABLE_COMMANDS and not cmd.startswith("-"):
                suggestion = suggest_command(cmd)
                if suggestion:
                    show_error(
                        f"Unknown command '{cmd}'",
                        suggestion=f"Did you mean '[cyan]gitctx {suggestion}[/cyan]'?",
                        context=f"Available commands: {', '.join(AVAILABLE_COMMANDS)}",
                    )
                else:
                    show_error(
                        f"Unknown command '{cmd}'",
                        suggestion="Use '[cyan]gitctx --help[/cyan]' to see available commands",
                        context=f"Available commands: {', '.join(AVAILABLE_COMMANDS)}",
                    )
                sys.exit(1)
        raise

app.process = custom_process

# Enhanced error messages for missing arguments
def handle_missing_argument_error():
    """Provide helpful message for missing arguments."""
    import traceback
    tb = traceback.format_exc()

    if "search" in tb and "QUERY" in tb:
        show_error(
            "Missing required argument: QUERY",
            suggestion="Usage: [cyan]gitctx search \"your search query\"[/cyan]",
            context="The search command requires a query string to find relevant code",
        )
    elif "config set" in tb:
        show_error(
            "Missing required arguments for config set",
            suggestion="Usage: [cyan]gitctx config set <key> <value>[/cyan]",
            context="Example: gitctx config set api_keys.openai sk-...",
        )
    elif "config get" in tb:
        show_error(
            "Missing required argument for config get",
            suggestion="Usage: [cyan]gitctx config get <key>[/cyan]",
            context="Example: gitctx config get api_keys.openai",
        )
    else:
        show_error(
            "Missing required argument",
            suggestion="Use --help to see the correct usage",
        )
```

Create `src/gitctx/cli/utils.py` for shared utilities:

```python
"""Shared utilities for CLI commands."""

from rich.console import Console
from rich.panel import Panel
from rich.text import Text

console = Console()

def show_mock_notice():
    """Display a notice that this is a mock implementation."""
    notice = Panel(
        Text("ðŸ”¬ This is a mock implementation for testing the CLI interface", style="italic dim"),
        border_style="yellow",
        padding=(0, 1),
    )
    console.print(notice)

def format_error(message: str) -> Panel:
    """Format an error message with Rich."""
    return Panel(
        Text(message, style="bold red"),
        title="Error",
        border_style="red",
        padding=(1, 2),
    )

def format_success(message: str) -> Panel:
    """Format a success message with Rich."""
    return Panel(
        Text(message, style="bold green"),
        title="Success",
        border_style="green",
        padding=(1, 2),
    )

def format_warning(message: str) -> Panel:
    """Format a warning message with Rich."""
    return Panel(
        Text(message, style="bold yellow"),
        title="Warning",
        border_style="yellow",
        padding=(1, 2),
    )
```

### BDD Scenarios

Enable in `tests/e2e/features/cli.feature`:

```gherkin
Scenario: Invalid command
  When I run "gitctx invalid"
  Then the exit code should not be 0
  And the output should contain "Unknown command 'invalid'"
  And the output should suggest valid commands

Scenario: Missing required arguments
  When I run "gitctx search"
  Then the exit code should not be 0
  And the output should contain "Missing"
  And the output should contain "QUERY"
  And the output should contain "Usage: gitctx search"
```

### Refactor

- Extract error formatting to separate error module
- Add logging for debugging
- Consider adding crash reporting
- Add more intelligent command suggestions

## Acceptance Criteria

- [x] Invalid commands show helpful error messages
- [x] Command typos get "did you mean?" suggestions
- [x] Missing arguments show usage examples
- [x] Invalid option values show valid ranges
- [x] All errors use Rich formatting consistently
- [x] Error messages include actionable next steps
- [x] Help flag works even with invalid commands
- [x] Empty command shows quick start guide
- [x] Unit tests pass for all error scenarios
- [x] BDD scenarios for error handling pass

## Dependencies

- All other command implementations should be complete
- Rich library for formatting (already installed)

## Testing Commands

```bash
# Run unit tests
uv run pytest tests/unit/cli/test_error_handling.py -v

# Run BDD tests
uv run pytest tests/e2e -k "invalid or missing" -v

# Manual testing - Invalid commands
uv run gitctx invalid
uv run gitctx serach  # Typo
uv run gitctx cofnig  # Typo

# Manual testing - Missing arguments
uv run gitctx search
uv run gitctx config set
uv run gitctx config get

# Manual testing - Invalid options
uv run gitctx search test --limit invalid
uv run gitctx search test --limit 0
uv run gitctx search test --limit 999

# Manual testing - Help
uv run gitctx
uv run gitctx --help
uv run gitctx invalid --help
```

## Notes

- Error messages should be helpful, not frustrating
- Suggestions help users recover from mistakes quickly
- Rich formatting makes errors visually distinct
- Consistent error format across all commands
- This completes the CLI framework with professional error handling
- Consider telemetry for common errors (with user consent)

---

**Created**: 2025-10-01
**Last Updated**: 2025-10-01