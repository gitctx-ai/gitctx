# TASK-0001.1.1.3: Implement Config Command Structure

**Parent Story**: [STORY-0001.1.1](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 2
**Actual Hours**: -

## Description

Implement the `config` command group with three subcommands: `set`, `get`, and `list`. The commands should demonstrate configuration management patterns including dot notation for nested values, environment variable precedence, and secure handling of sensitive values like API keys.

## Implementation Checklist

- [ ] Create `src/gitctx/cli/config.py` module
- [ ] Implement command group with Typer
- [ ] Add `config set <key> <value>` subcommand
- [ ] Add `config get <key>` subcommand
- [ ] Add `config list` subcommand
- [ ] Implement mock configuration storage
- [ ] Mask sensitive values in output (API keys)
- [ ] Show environment variable precedence
- [ ] Enable BDD tests: "Configure API key", "Display configuration", "Environment variable override"
- [ ] Add unit tests for all subcommands
- [ ] Verify dot notation works for nested keys

## TDD Requirements

### Test First (RED)

Write unit tests in `tests/unit/cli/test_config.py`:

```python
import pytest
import os
from typer.testing import CliRunner
from gitctx.cli.main import app

runner = CliRunner()

def test_config_command_exists():
    """Verify config command group is registered."""
    result = runner.invoke(app, ["config", "--help"])
    assert result.exit_code == 0
    assert "Manage gitctx configuration" in result.stdout

def test_config_set_command():
    """Verify config set subcommand works."""
    result = runner.invoke(app, ["config", "set", "api_keys.openai", "sk-test123"])
    assert result.exit_code == 0
    assert "set" in result.stdout.lower() or "saved" in result.stdout.lower()

def test_config_get_command():
    """Verify config get subcommand works."""
    # First set a value
    runner.invoke(app, ["config", "set", "api_keys.openai", "sk-test123"])
    # Then get it
    result = runner.invoke(app, ["config", "get", "api_keys.openai"])
    assert result.exit_code == 0
    # Should mask API key in output
    assert "sk-...123" in result.stdout or "***" in result.stdout

def test_config_list_command():
    """Verify config list subcommand works."""
    result = runner.invoke(app, ["config", "list"])
    assert result.exit_code == 0
    assert "Configuration" in result.stdout or "Settings" in result.stdout

def test_config_set_requires_value():
    """Verify set command requires both key and value."""
    result = runner.invoke(app, ["config", "set", "test.key"])
    assert result.exit_code != 0
    assert "Missing argument" in result.stdout

def test_config_get_requires_key():
    """Verify get command requires key."""
    result = runner.invoke(app, ["config", "get"])
    assert result.exit_code != 0
    assert "Missing argument" in result.stdout

def test_config_env_override(monkeypatch):
    """Verify environment variables override config."""
    monkeypatch.setenv("OPENAI_API_KEY", "sk-env123")
    result = runner.invoke(app, ["config", "get", "api_keys.openai"])
    assert result.exit_code == 0
    assert "env" in result.stdout.lower() or "environment" in result.stdout.lower()
    assert "sk-...123" in result.stdout or "***" in result.stdout

def test_config_dot_notation():
    """Verify dot notation works for nested keys."""
    result = runner.invoke(app, ["config", "set", "search.limit", "20"])
    assert result.exit_code == 0
    result = runner.invoke(app, ["config", "get", "search.limit"])
    assert result.exit_code == 0
    assert "20" in result.stdout

def test_config_list_masks_sensitive():
    """Verify list command masks sensitive values."""
    runner.invoke(app, ["config", "set", "api_keys.openai", "sk-secret123"])
    result = runner.invoke(app, ["config", "list"])
    assert result.exit_code == 0
    # Should not show full API key
    assert "sk-secret123" not in result.stdout
    assert "***" in result.stdout or "..." in result.stdout
```

### Implementation (GREEN)

Create `src/gitctx/cli/config.py`:

```python
"""Configuration management commands for gitctx CLI."""

import os
from typing import Optional, Dict, Any
from pathlib import Path
import typer
from rich.console import Console
from rich.table import Table
from rich.tree import Tree
from rich import print as rprint

console = Console()

# Mock in-memory config store (would be file-based in real implementation)
_mock_config: Dict[str, Any] = {
    "api_keys": {
        "openai": None,
        "anthropic": None,
    },
    "search": {
        "limit": 10,
        "rerank": True,
    },
    "index": {
        "chunk_size": 1000,
        "chunk_overlap": 200,
        "ignore_patterns": [".git", "__pycache__", "*.pyc"],
    },
    "model": {
        "embedding": "text-embedding-3-large",
        "reranking": "gpt-4",
    },
}

# Environment variable mappings
ENV_MAPPINGS = {
    "api_keys.openai": "OPENAI_API_KEY",
    "api_keys.anthropic": "ANTHROPIC_API_KEY",
}

config_app = typer.Typer(
    name="config",
    help="Manage gitctx configuration settings",
    rich_markup_mode="rich",
)

def register(app: typer.Typer) -> None:
    """Register the config command group with the CLI app."""
    app.add_typer(config_app, name="config")

def mask_sensitive_value(key: str, value: str) -> str:
    """Mask sensitive values like API keys."""
    if value and ("key" in key.lower() or "token" in key.lower() or "secret" in key.lower()):
        if len(value) > 8:
            return f"{value[:3]}...{value[-3:]}"
        else:
            return "***"
    return value

def get_nested_value(config: dict, key: str) -> Any:
    """Get value from nested dict using dot notation."""
    keys = key.split(".")
    value = config
    for k in keys:
        if isinstance(value, dict):
            value = value.get(k)
        else:
            return None
    return value

def set_nested_value(config: dict, key: str, value: Any) -> None:
    """Set value in nested dict using dot notation."""
    keys = key.split(".")
    current = config
    for k in keys[:-1]:
        if k not in current:
            current[k] = {}
        current = current[k]
    current[keys[-1]] = value

@config_app.command("set")
def config_set(
    key: str = typer.Argument(..., help="Configuration key (use dot notation for nested values)"),
    value: str = typer.Argument(..., help="Value to set"),
) -> None:
    """
    Set a configuration value.

    Examples:

        # Set OpenAI API key
        $ gitctx config set api_keys.openai sk-...

        # Set search limit
        $ gitctx config set search.limit 20

        # Set model preference
        $ gitctx config set model.embedding text-embedding-3-small
    """
    # Mock implementation
    set_nested_value(_mock_config, key, value)

    # Display confirmation
    masked_value = mask_sensitive_value(key, value)
    console.print(f"[green]âœ“[/green] Configuration updated")
    console.print(f"  [bold]{key}[/bold] = {masked_value}")

    # Show where it would be saved
    config_path = Path.home() / ".gitctx" / "config.yml"
    console.print(f"\n[dim]Configuration saved to: {config_path} (mock)[/dim]")

@config_app.command("get")
def config_get(
    key: str = typer.Argument(..., help="Configuration key to retrieve"),
) -> None:
    """
    Get a configuration value.

    Shows the effective value considering environment variables.

    Examples:

        # Get API key (will check OPENAI_API_KEY env var first)
        $ gitctx config get api_keys.openai

        # Get search limit
        $ gitctx config get search.limit
    """
    # Check environment variable first
    env_var = ENV_MAPPINGS.get(key)
    env_value = None
    source = "config file"

    if env_var:
        env_value = os.environ.get(env_var)
        if env_value:
            source = f"environment ({env_var})"

    # Get config value
    config_value = get_nested_value(_mock_config, key)
    effective_value = env_value or config_value

    if effective_value is None:
        console.print(f"[yellow]Configuration key '{key}' is not set[/yellow]")
        if env_var:
            console.print(f"[dim]Tip: You can set the {env_var} environment variable[/dim]")
        return

    # Mask sensitive values
    display_value = mask_sensitive_value(key, str(effective_value))

    # Display the value with source
    console.print(f"[bold]{key}[/bold] = {display_value}")
    console.print(f"[dim]Source: {source}[/dim]")

@config_app.command("list")
def config_list() -> None:
    """
    List all configuration values.

    Shows current configuration with environment variable overrides.

    Example:

        $ gitctx config list
    """
    console.print("[bold]Current Configuration[/bold]")
    console.print()

    # Create a tree view of configuration
    tree = Tree("gitctx config")

    def add_dict_to_tree(parent: Tree, d: dict, prefix: str = "") -> None:
        """Recursively add dict items to tree."""
        for key, value in d.items():
            full_key = f"{prefix}{key}" if prefix else key

            # Check for env override
            env_var = ENV_MAPPINGS.get(full_key)
            env_value = None
            if env_var:
                env_value = os.environ.get(env_var)

            if isinstance(value, dict):
                branch = parent.add(f"[cyan]{key}/[/cyan]")
                add_dict_to_tree(branch, value, f"{full_key}.")
            else:
                effective_value = env_value if env_value else value
                if effective_value is None:
                    display = "[dim]not set[/dim]"
                else:
                    display = mask_sensitive_value(full_key, str(effective_value))

                # Add source indicator
                if env_value:
                    display += f" [green](env: {env_var})[/green]"

                parent.add(f"[bold]{key}:[/bold] {display}")

    add_dict_to_tree(tree, _mock_config)
    console.print(tree)

    # Show config file location
    console.print()
    config_path = Path.home() / ".gitctx" / "config.yml"
    console.print(f"[dim]Configuration file: {config_path} (mock)[/dim]")

    # Show tips
    console.print()
    console.print("[bold]Tips:[/bold]")
    console.print("â€¢ Use [cyan]gitctx config set <key> <value>[/cyan] to update settings")
    console.print("â€¢ Environment variables override configuration file values")
    console.print("â€¢ API keys are automatically masked in output for security")

@config_app.callback()
def config_callback() -> None:
    """
    Manage gitctx configuration.

    Configuration values can be set via:
    1. Config file (~/.gitctx/config.yml)
    2. Environment variables (take precedence)
    3. Command line flags (highest precedence)
    """
    pass  # This is just for the help text
```

Update `src/gitctx/cli/main.py` to register the config command:

```python
# Register commands
from gitctx.cli import index, search, config

index.register(app)
search.register(app)
config.register(app)
```

### BDD Scenarios

Enable in `tests/e2e/features/cli.feature`:

```gherkin
Scenario: Configure API key
  When I run "gitctx config set api_keys.openai sk-test123"
  Then the configuration should be saved
  When I run "gitctx config get api_keys.openai"
  Then the output should contain "sk-...123"

Scenario: Display configuration
  Given the configuration contains API keys
  When I run "gitctx config list"
  Then the output should show all settings
  And sensitive values should be masked

Scenario: Environment variable override
  Given the environment variable "OPENAI_API_KEY" is set to "sk-env123"
  When I run "gitctx config get api_keys.openai"
  Then the output should contain "sk-...123"
  And the environment value should take precedence
```

### Refactor

- Extract configuration logic to separate Config class
- Add validation for known configuration keys
- Implement actual file persistence (YAML)
- Add config export/import commands

## Acceptance Criteria

- [x] `gitctx config` command group exists
- [x] `config set <key> <value>` saves configuration
- [x] `config get <key>` retrieves values
- [x] `config list` shows all configuration
- [x] Dot notation works for nested keys
- [x] Sensitive values are masked in output
- [x] Environment variables override config values
- [x] Help text includes examples
- [x] Unit tests pass for all subcommands
- [x] BDD scenarios for config pass

## Dependencies

- Parent story must be created
- Consider implementing after index and search for consistency

## Testing Commands

```bash
# Run unit tests
uv run pytest tests/unit/cli/test_config.py -v

# Run BDD tests
uv run pytest tests/e2e -k "config" -v

# Manual testing
uv run gitctx config --help
uv run gitctx config set api_keys.openai sk-test123
uv run gitctx config get api_keys.openai
uv run gitctx config list
uv run gitctx config set search.limit 20
uv run gitctx config get search.limit

# Test environment override
OPENAI_API_KEY=sk-env123 uv run gitctx config get api_keys.openai
```

## Notes

- Mock implementation uses in-memory storage for simplicity
- Real implementation will use YAML file at `~/.gitctx/config.yml`
- Sensitive value masking is critical for security
- Environment variable precedence follows 12-factor app principles
- Tree view makes nested configuration intuitive
- This establishes patterns for all configuration management

---

**Created**: 2025-10-01
**Last Updated**: 2025-10-01