# TASK-0001.1.1.2: Implement Search Command

**Parent Story**: [STORY-0001.1.1](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 1
**Actual Hours**: -

## Description

Add the `search` command to the CLI with a required query argument and optional limit flag. The command should have a mock implementation that demonstrates the expected search results format with context snippets and relevance scoring.

## Implementation Checklist

- [ ] Create `src/gitctx/cli/search.py` module
- [ ] Implement `register()` function to add command to app
- [ ] Add required `query` argument
- [ ] Add `--limit/-n` option (default: 10)
- [ ] Implement mock search results with Rich formatting
- [ ] Show relevance scores and context snippets
- [ ] Enable BDD test: "Search command help"
- [ ] Add unit tests for argument parsing
- [ ] Verify error handling for missing query

## TDD Requirements

### Test First (RED)

Write unit tests in `tests/unit/cli/test_search.py`:

```python
import pytest
from typer.testing import CliRunner
from gitctx.cli.main import app

runner = CliRunner()

def test_search_command_exists():
    """Verify search command is registered."""
    result = runner.invoke(app, ["search", "--help"])
    assert result.exit_code == 0
    assert "Search the indexed repository" in result.stdout

def test_search_requires_query():
    """Verify search requires a query argument."""
    result = runner.invoke(app, ["search"])
    assert result.exit_code != 0
    assert "Missing argument" in result.stdout or "required" in result.stdout.lower()

def test_search_with_query():
    """Verify search accepts query argument."""
    result = runner.invoke(app, ["search", "test query"])
    assert result.exit_code == 0
    assert "test query" in result.stdout

def test_search_limit_option():
    """Verify --limit option works."""
    result = runner.invoke(app, ["search", "test", "--limit", "5"])
    assert result.exit_code == 0
    # Should show at most 5 results in mock

def test_search_limit_short_flag():
    """Verify -n short flag for limit works."""
    result = runner.invoke(app, ["search", "test", "-n", "3"])
    assert result.exit_code == 0

def test_search_help_text():
    """Verify help text includes all options."""
    result = runner.invoke(app, ["search", "--help"])
    assert "QUERY" in result.stdout
    assert "--limit" in result.stdout
    assert "-n" in result.stdout
    assert "Number of results" in result.stdout

def test_search_with_spaces_in_query():
    """Verify multi-word queries work."""
    result = runner.invoke(app, ["search", "authentication logic"])
    assert result.exit_code == 0
    assert "authentication logic" in result.stdout
```

### Implementation (GREEN)

Create `src/gitctx/cli/search.py`:

```python
"""Search command for gitctx CLI."""

import typer
from rich.console import Console
from rich.table import Table
from rich.syntax import Syntax
from rich.panel import Panel
from typing import Optional

console = Console()

def register(app: typer.Typer) -> None:
    """Register the search command with the CLI app."""
    app.command(name="search")(search_command)

def search_command(
    query: str = typer.Argument(
        ...,
        help="The search query to find relevant code and documentation"
    ),
    limit: int = typer.Option(
        10,
        "--limit", "-n",
        help="Maximum number of results to return",
        min=1,
        max=100
    ),
) -> None:
    """
    Search the indexed repository for relevant code.

    This command searches through the indexed embeddings to find
    the most relevant code snippets and documentation for your query.

    Examples:

        # Search for authentication code
        $ gitctx search "authentication logic"

        # Limit results to 5
        $ gitctx search "database connection" --limit 5

        # Using short flag
        $ gitctx search "API endpoints" -n 3
    """
    # Mock implementation message
    console.print(f"[dim]Mock search results for: [bold]{query}[/bold][/dim]")
    console.print()

    # Mock search results
    mock_results = [
        {
            "file": "src/auth/login.py",
            "score": 0.92,
            "lines": "45-67",
            "context": """def authenticate_user(username: str, password: str) -> Optional[User]:
    \"\"\"Authenticate user with username and password.\"\"\"
    user = get_user_by_username(username)
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user"""
        },
        {
            "file": "src/auth/middleware.py",
            "score": 0.87,
            "lines": "12-25",
            "context": """class AuthenticationMiddleware:
    def __init__(self, app):
        self.app = app

    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            headers = dict(scope["headers"])
            auth_header = headers.get(b"authorization")
            if auth_header:
                # Process authentication token
                token = self.extract_token(auth_header)
                scope["user"] = await self.validate_token(token)"""
        },
        {
            "file": "docs/authentication.md",
            "score": 0.85,
            "lines": "34-41",
            "context": """## Authentication Flow

1. User submits credentials to `/api/login`
2. Server validates credentials against database
3. If valid, JWT token is generated with 24h expiry
4. Token is returned in response body
5. Client includes token in Authorization header for subsequent requests
6. Middleware validates token on each request"""
        },
        {
            "file": "tests/test_auth.py",
            "score": 0.76,
            "lines": "78-92",
            "context": """def test_login_with_valid_credentials():
    \"\"\"Test successful authentication.\"\"\"
    response = client.post("/api/login", json={
        "username": "testuser",
        "password": "testpass123"
    })
    assert response.status_code == 200
    assert "access_token" in response.json()
    assert response.json()["token_type"] == "bearer\""""
        },
    ]

    # Limit results based on option
    results_to_show = mock_results[:min(limit, len(mock_results))]

    # Display results count
    console.print(f"[green]Found {len(mock_results)} results[/green] (showing {len(results_to_show)})")
    console.print()

    # Display each result
    for i, result in enumerate(results_to_show, 1):
        # Result header with score
        header = f"[bold cyan]{i}.[/bold cyan] {result['file']}:{result['lines']} [dim](relevance: {result['score']:.2f})[/dim]"

        # Determine syntax highlighting based on file extension
        ext = result['file'].split('.')[-1]
        lexer = {
            'py': 'python',
            'js': 'javascript',
            'ts': 'typescript',
            'md': 'markdown',
            'jsx': 'jsx',
            'tsx': 'tsx',
        }.get(ext, 'text')

        # Create syntax highlighted code block
        syntax = Syntax(
            result['context'],
            lexer,
            theme="monokai",
            line_numbers=True,
            start_line=int(result['lines'].split('-')[0])
        )

        # Display result in a panel
        console.print(Panel(
            syntax,
            title=header,
            title_align="left",
            border_style="blue" if i == 1 else "dim",
            padding=(0, 1)
        ))

        if i < len(results_to_show):
            console.print()  # Add space between results

    # Show summary
    console.print()
    console.print(f"[dim]Search completed in 0.23s (mock timing)[/dim]")

    if len(mock_results) > limit:
        remaining = len(mock_results) - limit
        console.print(f"[yellow]Note:[/yellow] {remaining} more results available. Use --limit to see more.")
```

Update `src/gitctx/cli/main.py` to register the search command:

```python
# Register commands
from gitctx.cli import index, search

index.register(app)
search.register(app)
```

### BDD Scenario

Enable in `tests/e2e/features/cli.feature`:

```gherkin
Scenario: Search command help
  When I run "gitctx search --help"
  Then the output should contain "Search the indexed repository"
  And the exit code should be 0

Scenario: Missing required arguments
  When I run "gitctx search"
  Then the exit code should not be 0
  And the output should contain "Missing argument"
  And the output should contain "QUERY"
```

### Refactor

- Extract result formatting to separate function
- Consider adding export options (JSON, CSV)
- Add query validation/sanitization

## Acceptance Criteria

- [x] `gitctx search <query>` command is executable
- [x] Query argument is required
- [x] `--limit/-n` option controls result count
- [x] Results show file path, line numbers, and relevance score
- [x] Code snippets are syntax highlighted
- [x] Help text includes usage examples
- [x] Error shown for missing query argument
- [x] Unit tests pass for all command variations
- [x] BDD scenarios for search pass

## Dependencies

- Parent story must be created
- Index command should be implemented first (for consistency)

## Testing Commands

```bash
# Run unit tests
uv run pytest tests/unit/cli/test_search.py -v

# Run BDD test
uv run pytest tests/e2e -k "search" -v

# Manual testing
uv run gitctx search --help
uv run gitctx search "authentication"
uv run gitctx search "database connection" --limit 5
uv run gitctx search "API endpoints" -n 3
uv run gitctx search  # Should show error
```

## Notes

- Mock results should demonstrate various file types (Python, JS, Markdown)
- Relevance scores help users understand ranking
- Syntax highlighting improves readability
- Consider showing query expansion in verbose mode (future)
- This establishes the UX pattern for displaying search results

---

**Created**: 2025-10-01
**Last Updated**: 2025-10-01