# TASK-0001.1.0.3: BDD/TDD Framework Setup

**Parent Story**: [STORY-0001.1.0](../stories/STORY-0001.1.0.md)  
**Status**: ✅ Complete  
**Estimated Hours**: 4  
**Actual Hours**: 1

## Description

Set up the complete BDD and TDD testing framework with pytest, pytest-bdd, and coverage reporting. Create the test directory structure, shared fixtures, and write the first passing BDD test to verify the framework works.

## Implementation Checklist

- [x] Create test directory structure (unit/ and e2e/)
- [x] Set up conftest.py with shared fixtures
- [x] Configure pytest-bdd for Gherkin scenarios
- [x] Write first BDD feature file (cli.feature)
- [x] Implement step definitions for basic scenario
- [x] Set up coverage reporting
- [x] Create test runner script
- [x] Verify all tests pass with coverage >85%

## TDD Requirements

### Test First (RED)

Not applicable.

### Implementation (GREEN)

#### Test Structure

```bash
tests/
├── __init__.py
├── conftest.py              # Root fixtures
├── e2e/
│   ├── __init__.py
│   ├── conftest.py          # E2E fixtures
│   ├── features/
│   │   └── cli.feature      # First feature file
│   ├── steps/
│   │   ├── __init__.py
│   │   └── cli_steps.py     # Step definitions
│   └── test_features.py     # Auto-discover scenarios
└── unit/
    ├── __init__.py
    └── test_framework.py     # Framework tests
```

### ⚠️ CRITICAL SECURITY REQUIREMENT

Git operations in tests MUST be isolated to prevent:
- Access to developer SSH keys
- Access to GPG signing keys  
- Pushing to real repositories
- Using real git credentials

ALL fixtures MUST inherit from the base isolation fixtures described below.

#### Root conftest.py

```python
# tests/conftest.py
"""
=== FIXTURE ARCHITECTURE ===

SECURITY: All git operations must use isolation fixtures to prevent
access to developer credentials, SSH keys, and GPG keys.

Current Fixtures: 2 core fixtures
Future Expansion: See roadmap in comments below

Author: gitctx team
"""
import pytest
import sys
import os
from pathlib import Path
import subprocess

# Add src to path for testing
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

# === PHASE 1: Core Security Fixtures (Current) ===

@pytest.fixture
def git_isolation_base():
    """
    Base git isolation configuration.
    
    SECURITY: This dict contains environment variables that prevent:
    - SSH key access
    - GPG signing
    - Credential helper access
    - Push operations
    
    All git-related fixtures MUST use this as a base.
    """
    return {
        # Disable git configuration access
        "GIT_CONFIG_GLOBAL": "/dev/null",
        "GIT_CONFIG_SYSTEM": "/dev/null",
        "GIT_TERMINAL_PROMPT": "0",
        "GIT_ASKPASS": "/bin/false",
        
        # Completely disable SSH
        "GIT_SSH_COMMAND": "/bin/false",
        "SSH_AUTH_SOCK": "",
        "SSH_ASKPASS": "/bin/false",
        
        # Disable GPG signing
        "GPG_TTY": "",
        "GNUPGHOME": "/dev/null",
    }

@pytest.fixture
def temp_home(tmp_path):
    """
    Create isolated HOME directory for tests.
    
    Returns:
        Path: Temporary home directory with .gitctx subdir
    """
    home = tmp_path / "test_home"
    home.mkdir()
    (home / ".gitctx").mkdir()
    return home

# === PHASE 2: Repository Fixtures (TODO - Next Sprint) ===
# TODO: unit_git_repo - Simple repo for unit tests (monkeypatch)
# TODO: unit_mock_filesystem - Mock file operations

# === PHASE 3: Service Mocks (TODO - Future) ===
# TODO: mock_openai_client - Mock OpenAI API responses
# TODO: mock_embeddings - Pre-generated test embeddings

# === EXPANSION GUIDELINES ===
#
# When adding new fixtures:
# 1. MUST use git_isolation_base for any git operations
# 2. Prefix with unit_ for monkeypatch-based fixtures
# 3. Document security implications
# 4. Add to appropriate phase in roadmap
```

#### E2E conftest.py

```python
# tests/e2e/conftest.py
"""
=== E2E FIXTURE ARCHITECTURE ===

CRITICAL: E2E tests spawn subprocesses. Monkeypatch DOES NOT WORK.
Must use actual environment dictionaries for isolation.

Current Fixtures: 4 fixtures for CLI/subprocess testing
Future Expansion: See roadmap in comments below

Author: gitctx team
"""
import pytest
import subprocess
import os
from pathlib import Path
from typer.testing import CliRunner

# === PHASE 1: Core E2E Fixtures (Current) ===

@pytest.fixture
def e2e_git_isolation_env(git_isolation_base, temp_home):
    """
    Complete environment dict for subprocess/CLI testing.
    
    SECURITY: This environment prevents:
    - Access to real SSH keys
    - GPG signing operations
    - Git credential access
    - Push to remote repos
    
    Args:
        git_isolation_base: Security isolation vars
        temp_home: Isolated HOME directory
    
    Returns:
        dict: Complete isolated environment for subprocess.run()
    
    Example:
        def test_git_operations(e2e_git_isolation_env):
            result = subprocess.run(
                ["git", "init"],
                env=e2e_git_isolation_env,
                capture_output=True
            )
    """
    # Start with minimal safe environment
    isolated_env = {
        "PATH": os.environ.get("PATH", "/usr/bin:/bin"),
        "HOME": str(temp_home),
        "USER": "testuser",
        "TERM": "dumb",
        "LANG": "C.UTF-8",
        "LC_ALL": "C.UTF-8",
    }
    
    # Add git isolation
    isolated_env.update(git_isolation_base)
    
    # Create minimal .gitconfig in isolated home
    gitconfig = temp_home / ".gitconfig"
    gitconfig.write_text("""[user]
    name = Test User
    email = test@example.com
[commit]
    gpgsign = false
[core]
    sshCommand = /bin/false
""")
    
    return isolated_env

@pytest.fixture
def e2e_cli_runner(e2e_git_isolation_env):
    """
    CLI runner with isolated environment.
    
    Uses CliRunner with complete environment isolation for testing
    gitctx CLI commands safely.
    
    Returns:
        CliRunner: Runner configured with isolated environment
        
    Example:
        def test_cli_command(e2e_cli_runner):
            result = e2e_cli_runner.invoke(app, ["--version"])
            assert result.exit_code == 0
    """
    return CliRunner(env=e2e_git_isolation_env)

@pytest.fixture
def e2e_git_repo(e2e_git_isolation_env, tmp_path):
    """
    Create basic git repository with isolation.
    
    Creates a git repo with one Python file, proper .gitignore,
    and complete isolation from system git configuration.
    
    Returns:
        Path: Repository root directory
        
    Example:
        def test_with_repo(e2e_git_repo, e2e_cli_runner):
            os.chdir(e2e_git_repo)
            result = e2e_cli_runner.invoke(app, ["index"])
    """
    repo_path = tmp_path / "test_repo"
    repo_path.mkdir()
    
    # Initialize git with isolation
    result = subprocess.run(
        ["git", "init"],
        cwd=repo_path,
        env=e2e_git_isolation_env,
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        pytest.fail(f"git init failed: {result.stderr}")
    
    # Configure git locally (not globally)
    for cmd in [
        ["git", "config", "user.name", "Test User"],
        ["git", "config", "user.email", "test@example.com"],
        ["git", "config", "commit.gpgsign", "false"],
    ]:
        subprocess.run(cmd, cwd=repo_path, env=e2e_git_isolation_env, check=True)
    
    # Add basic files
    (repo_path / "main.py").write_text('print("Hello from gitctx test")')
    (repo_path / ".gitignore").write_text("*.pyc\n__pycache__/\n.gitctx/\n")
    
    # Initial commit
    subprocess.run(["git", "add", "."], cwd=repo_path, env=e2e_git_isolation_env, check=True)
    subprocess.run(
        ["git", "commit", "-m", "Initial commit"],
        cwd=repo_path,
        env=e2e_git_isolation_env,
        check=True
    )
    
    return repo_path

@pytest.fixture
def e2e_env_factory(e2e_git_isolation_env):
    """
    Factory for creating custom environments with isolation.
    
    SECURITY: Prevents overriding critical security variables.
    
    Returns:
        callable: Factory function that creates custom env dicts
        
    Example:
        def test_with_api_key(e2e_env_factory):
            env = e2e_env_factory(OPENAI_API_KEY="sk-test123")
            result = subprocess.run(["gitctx", "search"], env=env)
    """
    def _make_env(**kwargs):
        env = e2e_git_isolation_env.copy()
        
        # Security check - don't allow overriding critical vars
        forbidden = {"GIT_SSH_COMMAND", "SSH_AUTH_SOCK", "GNUPGHOME", "GPG_TTY"}
        if forbidden & set(kwargs.keys()):
            raise ValueError(f"Cannot override security-critical vars: {forbidden & set(kwargs.keys())}")
        
        env.update(kwargs)
        return env
    
    return _make_env

# === PHASE 2: Repository Variants (TODO - Next Sprint) ===
# TODO: e2e_empty_git_repo - Just git init, no files
# TODO: e2e_git_repo_with_history - Multiple commits for history testing
# TODO: e2e_git_repo_with_branches - Multiple branches for branch testing
# TODO: e2e_large_git_repo - 1000+ files for performance testing

# === PHASE 3: Advanced Fixtures (TODO - Future) ===
# TODO: e2e_indexed_repo - Repository with completed indexing
# TODO: e2e_git_repo_factory - Parameterized repo builder
# TODO: mock_openai_api - Subprocess-safe OpenAI mock

# === COMPOSITION PATTERNS ===
#
# PATTERN 1: Extending existing fixtures
# @pytest.fixture
# def e2e_repo_with_config(e2e_git_repo):
#     """Add .gitctx config to repo."""
#     config_path = e2e_git_repo / ".gitctx" / "config.yml"
#     config_path.parent.mkdir(exist_ok=True)
#     config_path.write_text("model: gpt-4")
#     return e2e_git_repo
#
# PATTERN 2: Parameterized fixtures
# @pytest.fixture
# def e2e_repo_with_files(request, e2e_git_repo, e2e_git_isolation_env):
#     """Create repo with custom files via params."""
#     for filename, content in request.param.items():
#         (e2e_git_repo / filename).write_text(content)
#     subprocess.run(
#         ["git", "add", "-A"],
#         cwd=e2e_git_repo,
#         env=e2e_git_isolation_env,
#         check=True
#     )
#     return e2e_git_repo

# === SECURITY VERIFICATION ===
#
# To verify isolation is working, these commands should FAIL in tests:
# - subprocess.run(["git", "push"], env=e2e_git_isolation_env)  # No SSH
# - subprocess.run(["ssh", "-T", "git@github.com"], env=e2e_git_isolation_env)  # No SSH
# - subprocess.run(["gpg", "--list-secret-keys"], env=e2e_git_isolation_env)  # No GPG
```

#### First Feature File

```gherkin
# tests/e2e/features/cli.feature
Feature: CLI Foundation
  As a developer
  I want to use gitctx from the command line
  So that I can search my codebase effectively

  Scenario: Display version
    Given gitctx is installed
    When I run "gitctx --version"
    Then the output should contain "gitctx version"
    And the exit code should be 0

  Scenario: Display help
    Given gitctx is installed
    When I run "gitctx --help"
    Then the output should contain "Usage: gitctx"
    And the output should contain "Context optimization engine"
    And the exit code should be 0
```

#### Step Definitions

```python
# tests/e2e/steps/cli_steps.py
import pytest
from pytest_bdd import given, when, then, parsers
from typer.testing import CliRunner

# Store results in pytest context
@pytest.fixture
def context():
    """Store test context between steps."""
    return {}

@given("gitctx is installed")
def gitctx_installed():
    """Verify gitctx can be imported."""
    import gitctx
    assert gitctx.__version__

@when(parsers.parse('I run "{command}"'))
def run_command(command, cli_runner, context):
    """Execute a CLI command."""
    from gitctx.cli.main import app
    args = command.replace("gitctx", "").strip().split()
    result = cli_runner.invoke(app, args)
    context["result"] = result
    context["output"] = result.stdout
    context["exit_code"] = result.exit_code
    return result

@then(parsers.parse('the output should contain "{text}"'))
def check_output_contains(text, context):
    """Verify text appears in output."""
    assert text in context["output"], \
        f"Expected '{text}' in output, got: {context['output']}"

@then("the exit code should be 0")
def check_exit_code_zero(context):
    """Verify command succeeded."""
    assert context["exit_code"] == 0, \
        f"Expected exit code 0, got {context['exit_code']}"

@then(parsers.parse("the exit code should be {code:d}"))
def check_exit_code(code, context):
    """Verify specific exit code."""
    assert context["exit_code"] == code
```

#### Test Runner

```python
# tests/e2e/test_features.py
"""Auto-discover and run all BDD scenarios."""
from pytest_bdd import scenarios

# This will automatically discover and run all .feature files
scenarios('features')
```

### Fixture Naming Conventions and Usage

#### Naming Prefixes

| Prefix | Usage | Location | Testing Type |
|--------|-------|----------|--------------|
| `unit_` | Unit test fixtures using monkeypatch | `tests/conftest.py` | In-process |
| `e2e_` | E2E fixtures returning env dicts | `tests/e2e/conftest.py` | Subprocess/CLI |
| `mock_` | Service mocks | Either location | Both |
| No prefix | Shared utilities | Either location | Both |

#### Critical Difference: Monkeypatch vs Environment Dicts

**Unit Tests (monkeypatch works):**
```python
def test_unit_with_mock_env(monkeypatch):
    monkeypatch.setenv("OPENAI_API_KEY", "sk-test")
    # This works for in-process testing
    from gitctx.config import Config
    config = Config()
    assert config.api_key == "sk-test"
```

**E2E Tests (must use env dict):**
```python
def test_e2e_with_isolated_env(e2e_env_factory):
    env = e2e_env_factory(OPENAI_API_KEY="sk-test")
    # Must pass env dict to subprocess
    result = subprocess.run(
        ["gitctx", "config", "get"],
        env=env,  # CRITICAL: Pass the actual env dict!
        capture_output=True
    )
```

### Security Verification Tests

Add these tests to verify fixture isolation:

```python
# tests/e2e/test_security_isolation.py
def test_git_push_fails(e2e_git_repo, e2e_git_isolation_env):
    """Verify git push cannot access SSH keys."""
    result = subprocess.run(
        ["git", "push", "origin", "main"],
        cwd=e2e_git_repo,
        env=e2e_git_isolation_env,
        capture_output=True
    )
    assert result.returncode != 0
    assert b"/bin/false" in result.stderr or b"fatal" in result.stderr

def test_ssh_disabled(e2e_git_isolation_env):
    """Verify SSH is completely disabled."""
    result = subprocess.run(
        ["ssh", "-T", "git@github.com"],
        env=e2e_git_isolation_env,
        capture_output=True,
        timeout=1
    )
    assert result.returncode != 0

def test_gpg_isolated(e2e_git_isolation_env):
    """Verify GPG keys are not accessible."""
    result = subprocess.run(
        ["gpg", "--list-secret-keys"],
        env=e2e_git_isolation_env,
        capture_output=True
    )
    # Should have no keys or fail to access keyring
    assert b"secret key" not in result.stdout.lower()
```

### Refactor

- Extract common fixtures to conftest
- Add more detailed error messages
- Consider parallel test execution setup
- Regularly verify security isolation is working

## Acceptance Criteria

- [x] Test directory structure is complete
- [x] pytest-bdd is configured and working
- [x] First BDD scenario passes (version display)
- [x] Coverage reporting is configured
- [x] Tests can be run with `uv run pytest`
- [x] Coverage is reported with tests
- [x] All test files have proper docstrings

## Dependencies

- pytest and pytest-bdd installed
- Basic CLI structure from TASK-0001.1.0.1
- pyproject.toml from TASK-0001.1.0.2

## Testing Commands

```bash
# Run all tests
uv run pytest

# Run with verbose output
uv run pytest -v

# Run only unit tests
uv run pytest tests/unit/

# Run only BDD tests
uv run pytest tests/e2e/

# Run with coverage
uv run pytest --cov=src/gitctx

# Run specific feature
uv run pytest tests/e2e/ -k "version"

# Generate HTML coverage report
uv run pytest --cov=src/gitctx --cov-report=html
```

## Fixture Testing

### Test Files for Fixtures

Each test directory should have its own fixture test file to verify fixtures work correctly:

#### tests/unit/test_fixtures.py

```python
# tests/unit/test_fixtures.py
"""
Test fixtures defined in tests/conftest.py (root fixtures).

When adding new fixtures to tests/conftest.py, add corresponding
tests here to verify behavior.
"""
import os
from pathlib import Path

def test_git_isolation_base(git_isolation_base):
    """Verify git isolation base contains security vars."""
    assert git_isolation_base["GIT_SSH_COMMAND"] == "/bin/false"
    assert git_isolation_base["SSH_AUTH_SOCK"] == ""
    assert git_isolation_base["GNUPGHOME"] == "/dev/null"
    assert git_isolation_base["GIT_TERMINAL_PROMPT"] == "0"

def test_temp_home(temp_home):
    """Verify temp_home creates proper structure."""
    assert temp_home.exists()
    assert temp_home.is_dir()
    assert (temp_home / ".gitctx").exists()
    assert (temp_home / ".gitctx").is_dir()
    # Verify it's actually temporary
    assert "/tmp" in str(temp_home) or "Temp" in str(temp_home)

# TODO: When adding unit_* fixtures, add tests here:
# def test_unit_mock_api_key(unit_mock_api_key):
#     """Verify unit mock API key is set correctly."""
#     import os
#     assert os.environ.get("OPENAI_API_KEY") == "sk-test123"
```

#### tests/e2e/test_fixtures.py

```python
# tests/e2e/test_fixtures.py
"""
Test E2E fixtures defined in tests/e2e/conftest.py.

CRITICAL: These tests verify security isolation is working.
When adding new E2E fixtures, add tests here.
"""
import subprocess
import os
from pathlib import Path

def test_e2e_git_isolation_env_security(e2e_git_isolation_env):
    """Verify environment has all security isolation vars."""
    # Check SSH is disabled
    assert e2e_git_isolation_env["GIT_SSH_COMMAND"] == "/bin/false"
    assert e2e_git_isolation_env["SSH_AUTH_SOCK"] == ""
    
    # Check GPG is disabled
    assert e2e_git_isolation_env["GNUPGHOME"] == "/dev/null"
    assert e2e_git_isolation_env["GPG_TTY"] == ""
    
    # Check git config is isolated
    assert e2e_git_isolation_env["GIT_CONFIG_GLOBAL"] != os.path.expanduser("~/.gitconfig")
    assert e2e_git_isolation_env["GIT_CONFIG_SYSTEM"] == "/dev/null"
    
    # Check HOME is isolated
    assert e2e_git_isolation_env["HOME"] != os.path.expanduser("~")
    assert "tmp" in e2e_git_isolation_env["HOME"].lower() or "temp" in e2e_git_isolation_env["HOME"].lower()

def test_e2e_git_isolation_prevents_ssh(e2e_git_isolation_env):
    """Verify SSH operations fail with isolation."""
    result = subprocess.run(
        ["ssh", "-T", "git@github.com"],
        env=e2e_git_isolation_env,
        capture_output=True,
        timeout=2
    )
    assert result.returncode != 0

def test_e2e_cli_runner_has_isolation(e2e_cli_runner):
    """Verify CLI runner uses isolated environment."""
    # The env should be set on the runner
    assert e2e_cli_runner.env is not None
    assert e2e_cli_runner.env["GIT_SSH_COMMAND"] == "/bin/false"

def test_e2e_git_repo_structure(e2e_git_repo):
    """Verify git repo has expected structure."""
    assert e2e_git_repo.exists()
    assert (e2e_git_repo / ".git").exists()
    assert (e2e_git_repo / "main.py").exists()
    assert (e2e_git_repo / ".gitignore").exists()
    
    # Verify git config is local only
    config_file = e2e_git_repo / ".git" / "config"
    config_text = config_file.read_text()
    assert "user" in config_text
    assert "test@example.com" in config_text

def test_e2e_git_repo_cannot_push(e2e_git_repo, e2e_git_isolation_env):
    """SECURITY: Verify repo cannot push to remote."""
    # Try to add a remote and push
    subprocess.run(
        ["git", "remote", "add", "origin", "git@github.com:test/test.git"],
        cwd=e2e_git_repo,
        env=e2e_git_isolation_env
    )
    
    result = subprocess.run(
        ["git", "push", "origin", "main"],
        cwd=e2e_git_repo,
        env=e2e_git_isolation_env,
        capture_output=True,
        timeout=2
    )
    assert result.returncode != 0

def test_e2e_env_factory_blocks_security_overrides(e2e_env_factory):
    """Verify factory prevents overriding security vars."""
    import pytest
    
    # Should work for normal vars
    env = e2e_env_factory(CUSTOM_VAR="test")
    assert env["CUSTOM_VAR"] == "test"
    
    # Should fail for security vars
    with pytest.raises(ValueError, match="security-critical"):
        e2e_env_factory(GIT_SSH_COMMAND="ssh")
    
    with pytest.raises(ValueError, match="security-critical"):
        e2e_env_factory(SSH_AUTH_SOCK="/tmp/ssh-agent")

# TODO: When adding new e2e_* fixtures, add tests here:
# def test_e2e_empty_git_repo(e2e_empty_git_repo):
#     """Verify empty repo has only .git directory."""
#     assert (e2e_empty_git_repo / ".git").exists()
#     # Should have no other files
#     files = list(e2e_empty_git_repo.iterdir())
#     assert len(files) == 1  # Only .git
```

## Notes

### Security First

- **CRITICAL**: All git operations must use isolation fixtures to prevent access to developer credentials
- Tests must never be able to access SSH keys, GPG keys, or git credentials
- Verify isolation is working by running `pytest tests/e2e/test_fixtures.py::test_e2e_git_isolation_prevents_ssh`

### Fixture Architecture

- Start with minimal fixtures (5 total) that provide security isolation
- Clear naming convention: `unit_` for monkeypatch-based, `e2e_` for subprocess/env dicts
- **Remember**: Monkeypatch doesn't work for subprocesses - use env dicts for E2E tests
- All future fixtures must inherit from the security base fixtures
- **Always add tests** in `test_fixtures.py` when creating new fixtures

### Expansion Roadmap

- Phase 1 (Current): Core security fixtures
- Phase 2 (Next): Repository variants (empty, with history, with branches, large)
- Phase 3 (Future): Service mocks (OpenAI, embeddings, LanceDB)
- Follow composition patterns documented in conftest.py files
- **Update `test_fixtures.py`** files when adding new fixtures (see TODO comments)

### Best Practices

- Build up the test framework incrementally
- Ensure tests are isolated and don't affect each other
- Use fixtures to share common setup
- Keep step definitions reusable across features
- Document all new fixtures with security implications
- **Test your fixtures** - add tests to verify behavior in `test_fixtures.py`
- This framework will be the foundation for all future testing

---

**Created**: 2025-09-28  
**Last Updated**: 2025-09-28
